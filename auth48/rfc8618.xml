<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<rfc ipr="trust200902" category="std" number="8618" submissionType="IETF"
     consensus="yes">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc comments="no"?>

<front>
<title abbrev="C-DNS: A Format for DNS Packet Capture ">Compacted-DNS (C-DNS): A Format for DNS Packet Capture</title>

<!-- [rfced] May the title be updated as follows?  The rationale is to
avoid using "DNS packet capture" in the attributive position before
"format".

OLD: Compacted-DNS (C-DNS): A DNS Packet Capture Format
NEW: Compacted-DNS (C-DNS): A Format for DNS Packet Capture

Similarly, with the abbreviated title (in the running header):
OLD: C-DNS: A DNS Packet Capture Format
NEW: C-DNS: A Format for DNS Packet Capture 
-->

<author initials="J." surname="Dickinson" fullname="John Dickinson">
<organization>Sinodun IT</organization>
<address>
<postal>
<street>Magdalen Centre</street>
<street>Oxford Science Park</street>
<city>Oxford</city>
<code>OX4 4GA</code>
<country>United Kingdom</country>
</postal>
<email>jad@sinodun.com</email>
</address>
</author>

<author initials="J." surname="Hague" fullname="Jim Hague">
<organization>Sinodun IT</organization>
<address>
<postal>
<street>Magdalen Centre</street>
<street>Oxford Science Park</street>
<city>Oxford</city>
<code>OX4 4GA</code>
<country>United Kingdom</country>
</postal>
<email>jim@sinodun.com</email>
</address>
</author>

<author initials="S." surname="Dickinson" fullname="Sara Dickinson">
<organization>Sinodun IT</organization>
<address>
<postal>
<street>Magdalen Centre</street>
<street>Oxford Science Park</street>
<city>Oxford</city>
<code>OX4 4GA</code>
<country>United Kingdom</country>
</postal>
<email>sara@sinodun.com</email>
</address>
</author>

<author initials="T." surname="Manderson" fullname="Terry Manderson">
<organization>ICANN</organization>
<address>
<postal>
<street>12025 Waterfront Drive</street>
<street> Suite 300</street>
<city>Los Angeles</city>
<region>CA</region>
<code>90094-2536</code>
<country>United States of America</country>
</postal>
<email>terry.manderson@icann.org</email>
</address>
</author>

<author initials="J." surname="Bond" fullname="John Bond">
<organization>ICANN</organization>
<address>
<postal>
<street>12025 Waterfront Drive</street>
<street> Suite 300</street>
<city>Los Angeles</city>
<region>CA</region>
<code>90094-2536</code>
<country>United States of America</country>
</postal>
<email>john.r.bond@gmail.com</email>
</address>
</author>

<date year="2019" month="June"/>

<keyword>DNS</keyword>

<abstract>
<t>This document describes a data representation for collections of
DNS messages.
The format is designed for efficient storage and transmission of large packet captures of DNS traffic;
it attempts to minimize the size of such packet capture files but retain the
full DNS message contents along with the most useful transport metadata.
It is intended to assist with
the development of DNS traffic-monitoring applications.
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>There has long been a need for server operators to collect DNS Queries and Responses
on authoritative and recursive name servers for monitoring and analysis.
This data is used in a number of ways, including traffic monitoring,
analyzing network attacks, and &quot;day in the life&quot; (DITL) <xref target="ditl"/> analysis.
</t>
<t>A wide variety of tools already exist that facilitate the collection of DNS
traffic data, such as the DNS Stats Collector (DSC) <xref target="dsc"/>, packetq <xref target="packetq"/>, dnscap <xref target="dnscap"/>, and
dnstap <xref target="dnstap"/>.

<!-- [rfced] Section 1:  We expanded "DSC" as "DNS Stats Collector."
Please let us know any objections.

Original:
 A wide variety of tools already exist that facilitate the collection
 of DNS traffic data, such as DSC [dsc], packetq [packetq], dnscap
 [dnscap] and dnstap [dnstap].

Currently:
 A wide variety of tools already exist that facilitate the collection
 of DNS traffic data, such as the DNS Stats Collector (DSC) [dsc],
 packetq [packetq], dnscap [dnscap], and dnstap [dnstap]. -->

 However, there is no standard exchange format for large DNS
packet captures. The PCAP ("packet capture") <xref target="pcap"/> format or
the PCAP Next Generation (PCAP-NG) <xref target="pcapng"/> format is typically
used in practice for packet captures, but these file formats can contain a
great deal of additional information that is not directly pertinent to DNS
traffic analysis and thus unnecessarily increases the capture file size.
Additionally, these tools and formats typically have no filter mechanism to
selectively record only certain fields at capture time, requiring
post-processing for anonymization or pseudonymization of data to protect user
privacy.
</t>
<t>There has also been work on using text-based formats to describe
DNS packets (for example, see <xref target="dnsxml"/> and <xref
target="RFC8427"/>), but this work is largely aimed at producing convenient
representations of single messages. </t>
<t>Many DNS operators may receive hundreds of thousands of Queries per second
on a single name server instance, so a mechanism to minimize the storage and
transmission size (and therefore upload overhead) of the data collected is
highly desirable.
</t>
<t>The format described in this document, C-DNS (Compacted-DNS), focuses on the problem of capturing and storing large packet capture
files of DNS traffic with the following goals in mind:
</t>
<t>
<list style="symbols">
<t>Minimize the file size for storage and transmission.</t>
<t>Minimize the overhead of producing the packet capture file and the cost of any further (general-purpose) compression of the file.</t>
</list>
</t>
<t>This document contains:
</t>
<t>
<list style="symbols">
<t>A discussion of some common use cases in which DNS data is collected; see <xref target="data-collection-use-cases"/>.</t>
<t>A discussion of the major design considerations in developing an efficient
data representation for collections of DNS messages; see <xref target="design-considerations"/>.</t>
<t>A description of why the Concise Binary Object Representation (CBOR) <xref target="RFC7049"/> was chosen for this format; see <xref target="choice-of-cbor"/>.</t>
<t>A conceptual overview of the C-DNS format; see <xref target="cdns-format-conceptual-overview"/>.</t>
<t>The definition of the C-DNS format for the collection of DNS messages; see <xref target="cdns-format-detailed-description"/>.</t>
<t>Notes on converting C-DNS data to PCAP format; see <xref target="cdns-to-pcap"/>.</t>
<t>Some high-level implementation considerations for applications designed to
produce C-DNS; see <xref target="data-collection"/>.</t>
</list>
</t>
</section>

<section anchor="terminology" title="Terminology">
    <t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;,
    &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL&nbsp;NOT&quot;,
    &quot;SHOULD&quot;, &quot;SHOULD&nbsp;NOT&quot;, &quot;RECOMMENDED&quot;,
    &quot;NOT&nbsp;RECOMMENDED&quot;, &quot;MAY&quot;, and
    &quot;OPTIONAL&quot; in this document are to be interpreted as described
    in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> when,
    and only when, they appear in all capitals, as shown here.</t>

<t>&quot;Packet&quot; refers to an individual IPv4 or IPv6 packet. Typically, packets are
UDP datagrams, but such packets may also be part of a TCP data stream. &quot;Message&quot;, unless otherwise
qualified, refers to a DNS payload extracted from a UDP datagram or a TCP data
stream.
</t>
<t>The parts of DNS messages are named as they are in <xref target="RFC1035"/>. Specifically,
the DNS message has five sections: Header, Question, Answer, Authority,
and Additional.
</t>
<t>Pairs of DNS messages are called a Query and a Response.
</t>
</section>

<section anchor="data-collection-use-cases" title="Data Collection Use Cases">
<t>From a purely server operator perspective, collecting full packet captures of all
packets going into or out of a name server provides the most comprehensive
picture of network activity. However, there are several
design choices or other limitations that are common to many DNS installations and operators.
</t>
<t>
<list style="symbols">
<t>DNS servers are hosted in a variety of situations:
<list style="symbols">
<t>Self-hosted servers</t>
<t>Third-party hosting (including multiple third parties)</t>
<t>Third-party hardware (including multiple third parties)</t>
</list></t>
<t>Data is collected under different conditions:
<list style="symbols">
<t>On well-provisioned servers running in a steady state</t>
<t>On heavily loaded servers</t>
<t>On virtualized servers</t>
<t>On servers that are under DoS attack</t>
<t>On servers that are unwitting intermediaries in DoS attacks</t>
</list></t>
<t>Traffic can be collected via a variety of mechanisms:
<list style="symbols">
<t>Within the name server implementation itself</t>
<t>On the same hardware as the name server itself</t>
<t>Using a network tap on an adjacent host to listen to DNS traffic</t>
<t>Using port mirroring to listen from another host</t>
</list></t>
<t>The capabilities of data collection (and upload) networks vary:
<list style="symbols">
<t>Out-of-band networks with the same capacity as the in-band network</t>
<t>Out-of-band networks with less capacity than the in-band network</t>
<t>Everything being on the in-band network</t>
</list></t>
</list>
</t>
<t>Thus, there is a wide range of use cases, from very limited data collection
environments (third-party hardware, servers that are under attack, packet capture
on the name server itself and no out-of-band network) to &quot;limitless&quot;
environments (self-hosted, well-provisioned servers, using a network tap or port
mirroring with out-of-band networks with the same capacity as the in-band network).
In the former case, it is infeasible to reliably collect full packet captures, especially if the server
is under attack. In the latter case, collection of full packet captures may be reasonable.
</t>
<t>As a result of these restrictions, the C-DNS data format is designed
with the most limited use case in mind, such that:
</t>
<t>
<list style="symbols">
<t>Data collection will occur on the same hardware as the name server itself</t>
<t>Collected data will be stored on the same hardware as the name server itself, at least temporarily</t>
<t>Collected data being returned to some central analysis system will use the same network interface as the DNS Queries and Responses</t>
<t>There can be multiple third-party servers involved</t>
</list>
</t>
<t>Because of these considerations, a major factor in the design of the
format is minimal storage size of the capture files.
</t>
<t>Another significant consideration for any application that records DNS traffic
is that the running of the name server software and the transmission of
DNS Queries and Responses are the most important jobs of a name server; capturing data is not.
Any data collection system co-located with the name server needs to be intelligent enough to
carefully manage its CPU, disk, memory, and network
utilization. This leads to designing a format that requires a relatively low
overhead to produce and minimizes the requirement for further potentially costly
compression.
</t>
<t>However, it is also essential that interoperability with less restricted
infrastructure is maintained. In particular, it is highly desirable that the
collection format should facilitate the re&nbhy;creation of common formats
(such as PCAP) that are as close to the original as is realistic, given the
restrictions above.
</t>
</section>

<section anchor="design-considerations" title="Design Considerations">
<t>This section presents some of the major design considerations used in the development of the C-DNS format.
</t>
<t>
<list style="numbers">
<t>The basic unit of data is a combined DNS Query and the associated Response
(a &quot;Query/Response (Q/R) data item&quot;). The same structure
will be used for unmatched Queries and Responses. Queries without Responses will be
captured omitting the Response data. Responses without Queries will be captured omitting the Query data (but using
the Question section from the Response, if present, as an identifying QNAME).
<list style="symbols">
<t>Rationale: A Query and the associated Response represent the basic level of a client's interaction with the server.
Also, combining the Query and Response into one item often reduces storage requirements due to
commonality in the data of the two messages.</t>
</list>
In the context of generating a C-DNS file, it is assumed that only
those DNS payloads that can be parsed to produce a well&nbhy;formed DNS
message are stored in the C-DNS format and that all other messages will
(optionally) be recorded as malformed messages.
Parsing a well-formed message means, at a minimum, the following:
<list style="symbols">
<t>The packet has a well-formed 12-byte DNS Header with a recognized OPCODE.</t>
<t>The section counts are consistent with the section contents.</t>
<t>All of the Resource Records (RRs) can be fully parsed.</t>
</list></t>
<t>All top-level fields in each Q/R data item will be optional.
<list style="symbols">
<t>Rationale: Different operators will have different requirements for data
to be available for analysis. Operators with minimal requirements should
not have to pay the cost of recording full data, though this will limit
the ability to perform certain kinds of data analysis and also to
reconstruct packet captures. For example, omitting the RRs
from a Response will reduce the C-DNS file size; in principle, Responses
can be synthesized if there is enough context. Operators may have
different policies for collecting user data and can choose to omit or
anonymize certain fields at capture time, e.g., client address.</t>
</list></t>
<t>Multiple Q/R data items will be collected into blocks in the format. Common data in a block will be abstracted and
referenced from individual Q/R data items by indexing. The maximum number of Q/R data items in a block will be configurable.
<list style="symbols">
<t>Rationale: This blocking and indexing action provides a significant reduction in the volume of file data generated.
Although this introduces complexity, it provides compression of the data that makes use of knowledge of the DNS message structure.</t>
<t>It is anticipated that the files produced can be subject to further compression using general-purpose compression tools.
Measurements show that blocking significantly reduces the CPU required to perform such strong compression. See <xref target="simple-versus-block-coding"/>.</t>
<t>Examples of commonality between DNS messages are that in most cases the
QUESTION RR is the same in the Query and Response and that there is a finite
set of Query 'signatures' (based on a subset of attributes). For many
authoritative servers, there is very likely to be a finite set of Responses that are generated, of which a large number are NXDOMAIN.</t>
</list></t>
<t>Traffic metadata can optionally be included in each block. Specifically, counts of some types of non-DNS packets
(e.g., ICMP, TCP resets) sent to the server may be of interest.</t>
<t>The wire-format content of malformed DNS messages may optionally be recorded.
<list style="symbols">
<t>Rationale: Any structured capture format that does not capture the DNS payload byte for
byte will be limited to some extent in that it cannot represent malformed DNS messages.
Only those messages that can be fully parsed and transformed into the
structured format can be fully represented. Note, however, that this can result in rather misleading statistics. For example, a
malformed Query that cannot be represented in the C-DNS format will lead to the (well-formed)
DNS Responses with error code FORMERR appearing as &quot;unmatched&quot;. Therefore, it can greatly aid downstream analysis
to have the wire format of the malformed DNS messages available directly in the C&nbhy;DNS&nbsp;file.</t>
</list></t>
</list>
</t>
</section>

<section anchor="choice-of-cbor" title="Choice of CBOR">
<t>This document presents a detailed format description using CBOR <xref target="RFC7049"/>.
</t>
<t>The choice of CBOR was made taking a number of factors into account.
</t>
<t>
<list style="symbols">
<t>CBOR is a binary representation and thus is economical in storage space.</t>
<t>Other binary representations were investigated, and whilst all had attractive features,
none had a significant advantage over CBOR. See <xref target="comparison-of-binary-formats"/> for some discussion of this.</t>
<t>CBOR is an IETF specification and is familiar to IETF participants. It is based on the now-common
ideas of lists and objects and thus requires very little familiarization for those in the wider industry.</t>
<t>CBOR is a simple format and can easily be implemented from scratch if
necessary. Formats that are more complex require library support, which may
present problems on unusual platforms.</t>
<t>CBOR can also be easily converted to text formats such as JSON <xref target="RFC8259"/> for debugging and other human inspection requirements.</t>
<t>CBOR data schemas can be described using the Concise Data Definition
Language (CDDL) <xref target="RFC8610"/>.</t>
</list>
</t>
</section>

<section anchor="cdns-format-conceptual-overview" title="C-DNS Format Conceptual Overview">
<t>The following figures show purely schematic representations of the C-DNS
format to convey the high-level structure of the C-DNS format.
<xref target="cdns-format-detailed-description"/> provides a detailed discussion of the CBOR
representation and individual elements.
</t>
<t><xref target="fig1"/> shows the C-DNS format at the top level, including the file header and
data blocks. The Query/Response data items, Address/Event Count data items, and
Malformed Message data items link to various Block Tables.
</t>

<figure align="center" title="The C-DNS Format" anchor="fig1"><artwork align="center">
+-------+
+ C-DNS |
+-------+--------------------------+
| File Type Identifier             |
+----------------------------------+
| File Preamble                    |
| +--------------------------------+
| | Format Version                 |
| +--------------------------------+
| | Block Parameters               |
+-+--------------------------------+
| Block                            |
| +--------------------------------+
| | Block Preamble                 |
| +--------------------------------+
| | Block Statistics               |
| +--------------------------------+
| | Block Tables                   |
| +--------------------------------+
| | Query/Response data items      |
| +--------------------------------+
| | Address/Event Count data items |
| +--------------------------------+
| | Malformed Message data items   |
+-+--------------------------------+
| Block                            |
| +--------------------------------+
| | Block Preamble                 |
| +--------------------------------+
| | Block Statistics               |
| +--------------------------------+
| | Block Tables                   |
| +--------------------------------+
| | Query/Response data items      |
| +--------------------------------+
| | Address/Event Count data items |
| +--------------------------------+
| | Malformed Message data items   |
+-+--------------------------------+
| Further Blocks...                |
+----------------------------------+
</artwork></figure>
<t><xref target="fig2"/> shows some more-detailed relationships within each
block, specifically those between the Query/Response data item and the
relevant Block Tables.
</t>

<figure align="center" title="The Query/Response Data Item and Subsidiary
 Tables" anchor="fig2"><artwork align="center">
+----------------+
| Query/Response |
+-------------------------+
| Time Offset             |
+-------------------------+             +------------------+
| Client Address          |------------&gt;| IP Address array |
+-------------------------+             +------------------+
| Client Port             |
+-------------------------+             +------------------+
| Transaction ID          |     +------&gt;| Name/RDATA array |&lt;------+
+-------------------------+     |       +------------------+       |
| Query Signature         |--+  |                                  |
+-------------------------+  |  |       +-----------------+        |
| Client Hoplimit (q)     |  +--)------&gt;| Query Signature |        |
+-------------------------+     |       +-----------------+------+ |
| Response Delay (r)      |     |       | Server Address         | |
+-------------------------+     |       +------------------------+ |
| Query Name              |--+--+       | Server Port            | |
+-------------------------+  |          +------------------------+ |
| Query Size (q)          |  |          | Transport Flags        | |
+-------------------------+  |          +------------------------+ |
| Response Size (r)       |  |          | QR Type                | |
+-------------------------+  |          +------------------------+ |
| Response Processing (r) |  |          | QR Signature Flags     | |
| +-----------------------+  |          +------------------------+ |
| | Bailiwick             |--+          | Query OPCODE (q)       | |
| +-----------------------+             +------------------------+ |
| | Flags                 |             | QR DNS Flags           | |
+-+-----------------------+             +------------------------+ |
| Extra Query info (q)    |             | Query RCODE (q)        | |
| +-----------------------+             +------------------------+ |
| | Question              |--+---+   +--+-Query Class/Type (q)   | |
| +-----------------------+      |   |  +------------------------+ |
| | Answer                |--+   |   |  | Query QDCOUNT (q)      | |
| +-----------------------+  |   |   |  +------------------------+ |
| | Authority             |--+   |   |  | Query ANCOUNT (q)      | |
| +-----------------------+  |   |   |  +------------------------+ |
| | Additional            |--+   |   |  | Query NSCOUNT (q)      | |
+-+-----------------------+  |   |   |  +------------------------+ |
| Extra Response info (r) |  |-+ |   |  | Query EDNS version (q) | |
| +-----------------------+  | | |   |  +------------------------+ |
| | Answer                |--+ | |   |  | EDNS UDP Size (q)      | |
| +-----------------------+  | | |   |  +------------------------+ |
| | Authority             |--+ | |   |  | Query OPT RDATA (q)    | |
| +-----------------------+  | | |   |  +------------------------+ |
| | Additional            |--+ | |   |  | Response RCODE (r)     | |
+-+-----------------------+    | |   |  +------------------------+ |
                               | |   |                             |
                               | |   |                             |
+ -----------------------------+ |   +----------+                  |
|                                |              |                  |
| + -----------------------------+              |                  |
| |  +---------------+  +----------+            |                  |
| +-&gt;| Question list |-&gt;| Question |            |                  |
|    | array         |  | array    |            |                  |
|    +---------------+  +----------+--+         |                  |
|                       | Name        |--+------)------------------+
|                       +-------------+  |      |  +------------+
|                       | Class/Type  |--)---+--+-&gt;| Class/Type |
|                       +-------------+  |   |     | array      |
|                                        |   |     +------------+--+
|                                        |   |     | CLASS         |
|    +---------------+  +----------+     |   |     +---------------+
+---&gt;| RR list array |-&gt;| RR array |     |   |     | TYPE          |
     +---------+-----+  +----------+--+  |   |     +---------------+
                        | Name        |--+   |
                        +-------------+      |
                        | Class/Type  |------+
                        +-------------+
</artwork></figure>

<t>In <xref target="fig2"/>, data items annotated (q) are only present when a
Query&wj;/Response has a Query, and those annotated (r) are only present when a
Query/Response Response is present.
</t>
<t>A C-DNS file begins with a file header containing a File Type Identifier and
a File Preamble. The File Preamble contains information on the file Format Version and an array of Block Parameters items
(the contents of which include Collection and Storage Parameters used for one or more blocks).
</t>
<t>The file header is followed by a series of Blocks.
</t>
<t>A Block consists of a Block Preamble item, some Block Statistics
for the traffic stored within the Block, and then various arrays of common data collectively called the Block Tables. This is then
followed by an array of the Query&wj;/Response data items detailing the Queries and Responses
stored within the Block. The array of Query&wj;/Response data items is in turn followed
by the Address/Event Count data items (an array of per-client counts of
particular IP events) and then Malformed Message data items (an array of
malformed messages that are stored in the Block).
</t>
<t>The exact nature of the DNS data will affect what block size is the best
fit; however, sample data for a root server indicated that block sizes up to
10,000 Q/R data items give good results. See <xref target="block-size-choice"/> for more details.
</t>
<t>This design exploits data commonality and block-based storage to minimize
the C-DNS file size. As a result, C-DNS cannot be streamed below the level of a
block.
</t>

<section anchor="block-parameters" title="Block Parameters">
<t>The details of the Block Parameters items are not shown in the diagrams but are discussed
here for context.
</t>
<t>An array of Block Parameters items is stored in the File Preamble (with
a minimum of one item at index 0); a Block Parameters item consists of a collection
of Storage and Collection Parameters that applies to any given Block.
An array is used in order to support use cases such as wanting
to merge C-DNS files from different sources. The Block Preamble item then
contains an optional index for the Block Parameters item that applies for that
Block; if not present, the index defaults to 0. Hence, in effect, a global
Block Parameters item is defined that can then be overridden per Block.
</t>
</section>

<section anchor="storage-parameters" title="Storage Parameters">
<t>The Block Parameters item includes a
Storage Parameters item -- this contains information about the specific data
fields stored in the C-DNS file.
</t>
<t>These parameters include:
</t>
<t>
<list style="symbols">
<t>The sub-second timing resolution used by the data.</t>
<t>Information (hints) on which optional data are omitted. See <xref target="optional-data-items"/>.</t>
<t>Recorded OPCODES <xref target="opcodes"/> and RR TYPEs <xref
target="rrtypes"/>. See <xref target="optional-rrs-and-opcodes"/>.</t>
<t>Flags indicating, for example, whether the data is sampled or anonymized.
See Sections&nbsp;<xref target="storage-flags" format="counter"/> and
<xref target="privacy-considerations" format="counter"/>.</t>
<t>Client and server IPv4 and IPv6 address prefixes. See <xref target="ip-address-storage"/>.</t>
</list>
</t>

<section anchor="optional-data-items" title="Optional Data Items">
<t>To enable implementations to store data to their precise requirements in
as space-efficient a manner as possible, all fields in the following arrays
are optional:
</t>
<t>
<list style="symbols">
<t>Query/Response</t>
<t>Query Signature</t>
<t>Malformed Messages</t>
</list>
</t>
<t>In other words, an
implementation can choose to omit any data item that is not required for
its use case. In addition, implementations may be configured to not record all
RRs or to only record messages with certain OPCODES.
</t>
<t>This does, however, mean that a consumer of a C-DNS file faces two problems:
</t>
<t>
<list style="numbers">
<t>How can it quickly determine if a file definitely does not contain the data items it requires to complete a
particular task (e.g., reconstructing DNS traffic or performing a specific piece of data analysis)?</t>
<t>How can it determine whether a data item is not present because it was
(1)&nbsp;explicitly not recorded or (2)&nbsp;not available/present?</t>
</list></t>

<t>For example, capturing C-DNS data from within a name server implementation
makes it unlikely that the Client Hoplimit can be recorded. Or, if
there is no Query ARCOUNT recorded and no Query OPT RDATA <xref target="RFC6891"/> recorded, is that
because no Query contained an OPT RR, or because that data was not stored?
</t>
<t>The Storage Parameters item therefore also contains a Storage Hints item, which specifies
which items the encoder of the file omits from the stored data and will therefore
never be present. (This approach is taken because a flag that indicated which items
were included for collection would not guarantee that the item was present --
only that it might be.)
An implementation decoding that file can then use these flags to quickly determine
whether the input data is rich enough for its needs.

<!-- [rfced] Section 6.2.1:  Does "these" mean "these items," or
something else?

Original (the previous sentence is included for possible context):
 (This approach is
 taken because a flag that indicated which items were included for
 collection would not guarantee that the item was present, only that
 it might be.)  An implementation decoding that file can then use
 these to quickly determine whether the input data is rich enough for
 its needs. -->

</t>
</section>

<section anchor="optional-rrs-and-opcodes" title="Optional RRs and OPCODEs">
<t>Also included in the Storage Parameters item are explicit arrays listing the
RR TYPEs and the OPCODEs to be recorded. These arrays remove any ambiguity over
whether e.g. messages containing particular OPCODEs are not present because (1)
certain OPCODEs did not occur or (2) the implementation is not configured to
record them.

<!-- [rfced] Section 6.2.2:  This sentence does not parse.  If the
suggested text is not correct, please clarify "These," what did not
occur, and "messages containing particular OPCODEs or are ..."

Original (the previous sentence is included for context):
 Also included in the Storage Parameters are explicit arrays listing
 the RR types and the OPCODEs to be recorded.  These remove any
 ambiguity over whether messages containing particular OPCODEs or are
 not present because they did not occur, or because the implementation
 is not configured to record them.

Suggested:
 These arrays remove
 any ambiguity over whether messages containing particular OPCODEs
 are not present because (1) certain OPCODEs did not occur or (2) the
 implementation is not configured to record them. -->

</t>
<t>In the case of OPCODEs, for a message to be fully parsable, the OPCODE must be known to the
collecting implementation. Any message with an OPCODE unknown to the collecting implementation
cannot be validated as correctly formed and so must be treated as malformed. Messages with
OPCODES known to the recording application but not listed in the Storage
Parameters item are discarded
by the recording application during C-DNS capture (regardless of whether they are malformed or not).
</t>
<t>In the case of RRs, each record in a message must be fully parsable, including
parsing the record RDATA, as otherwise the message cannot be validated
as correctly formed. Any RR with an RR TYPE not known to the collecting implementation
cannot be validated as correctly formed and so must be treated as malformed.
</t>
<t>Once a message is correctly parsed, an implementation is free to record only a subset of
the RRs present.
</t>
</section>

<section anchor="storage-flags" title="Storage Flags">
<t>The Storage Parameters item contains flags that can be used to indicate
if:
</t>
<t>
<list style="symbols">
<t>the data is anonymized,</t>
<t>the data is produced from sample data, or</t>
<t>names in the data have been normalized (converted to uniform case).</t>
</list>
</t>
<t>The Storage Parameters item also contains optional fields holding details of the
sampling method used and the anonymization method used. It is RECOMMENDED that
these fields contain URIs <xref target="RFC3986"/> pointing to resources describing the methods
used. See <xref target="privacy-considerations"/> for further discussion of anonymization and
normalization.
</t>
</section>

<section anchor="ip-address-storage" title="IP Address Storage">
<t>The format can store either full IP addresses or just IP prefixes; the
Storage Parameters item contains fields to indicate if only IP prefixes were
stored.

</t>
<t>If the IP address prefixes are absent, then full addresses are stored. In
this case, the IP version can be directly inferred from the stored address
length and the fields &quot;qr-transport-flags&quot; in QueryResponseSignature
and &quot;mm-transport-flags&quot; in MalformedMessageData (which contain the
IP version bit) are optional.
</t>
<t>If IP address prefixes are given, only the prefix bits of addresses are
stored. In this case, in order to determine the IP version, the fields
&quot;qr-transport-flags&quot; in QueryResponseSignature and
&quot;mm&nbhy;transport-flags&quot; in MalformedMessageData MUST
be present. See Sections&nbsp;<xref target="queryresponsesignature"
format="counter"/> and <xref target="malformedmessagedata" format="counter"/>.

</t>
<t>As an example of storing only IP prefixes, if a client IPv6 prefix of 48 is
specified, a client address of 2001:db8:85a3::8a2e:370:7334 will be stored as
0x20010db885a3, reducing address storage space requirements. Similarly, if a
client IPv4 prefix of 16 is specified, a client address of 192.0.2.1 will be
stored as 0xc000 (192.0).
</t>
</section>
</section>
</section>

<section anchor="cdns-format-detailed-description" title="C-DNS Format Detailed Description">
<t>The CDDL definition for the C-DNS format is given in <xref target="cddl"/>.
</t>

<section anchor="map-quantities-and-indexes" title="Map Quantities and Indexes">
<t>All map keys are integers with values specified in the CDDL. String keys
would significantly bloat the file size.
</t>
<t>All key values specified are positive integers under 24, so their CBOR
representation is a single byte. Positive integer values not currently
used as keys in a map are reserved for use in future standard extensions.
</t>
<t>Implementations may choose to add additional implementation-specific
entries to any map. Negative integer map keys are reserved for these
values. Key values from -1 to -24 also have a single-byte CBOR
representation, so such implementation-specific extensions are not at
any space efficiency disadvantage.
</t>
<t>An item described as an index is the index of the data item in the
referenced array. Indexes are 0-based.
</t>
</section>

<section anchor="tabular-representation" title="Tabular Representation">
<t>The following sections present the C-DNS specification in tabular
format with a detailed description of each item.
</t>
<t>In all quantities that contain bit flags, bit 0 indicates the least
significant bit, i.e., flag &quot;n&quot; in quantity
&quot;q&quot; is on if &quot;(q&nbsp;&amp;&nbsp;(1&nbsp;&lt;&lt;&nbsp;n)) != 0&quot;.
</t>
<t>For the sake of readability, all type and field names defined in the
CDDL definition are shown in double quotes. Type names are by
convention camel case (e.g., &quot;BlockTables&quot;), and field names are
lowercase with hyphens (e.g., &quot;block-tables&quot;).
</t>
<t>For the sake of brevity, the following conventions are used in the tables:
</t>
<t>
<list style="symbols">
<t>The column M marks whether items in a map are mandatory.
<list style="symbols">
<t>X - Mandatory items.</t>
<t>C - Conditionally mandatory items. Such items are usually optional but may
be mandatory in some configurations.</t>
<t>If the column is empty, the item is optional.</t>
</list></t>
<t>The column T gives the CBOR datatype of the item.
<list style="symbols">
<t>U - Unsigned integer.</t>
<t>I - Signed integer (i.e. either a CBOR unsigned integer or a CBOR negative integer).</t>

<!-- [rfced] Section 7.2:  Please confirm that "Signed integer
(that is, CBOR unsigned ...)" is correct; "Signed ... that is
unsigned" reads oddly.

Original:
 *  I - Signed integer (i.e.  CBOR unsigned or negative integer) -->

<t>B - Boolean.</t>
<t>S - Byte string.</t>
<t>T - Text string.</t>
<t>M - Map.</t>
<t>A - Array.</t>
</list></t>
</list>
</t>
<t>In the case of maps and arrays, more information on the type of each
value, including the CDDL definition name if applicable, is given in the
description.
</t>
</section>

<section anchor="file" title="&quot;File&quot;">
<t>A C-DNS file has an outer structure &quot;File&quot;, a map that contains the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>file-type-id</c><c>X</c><c>T</c><c>String &quot;C-DNS&quot; identifying the file type.</c>
<c></c><c></c><c></c><c></c>
<c>file-preamble</c><c>X</c><c>M</c><c>Version and parameter information for the whole file. &nbsp;Map of type &quot;FilePreamble&quot;; see <xref target="filepreamble"/>.</c>
<c></c><c></c><c></c><c></c>
<c>file-blocks</c><c>X</c><c>A</c><c>Array of items of type &quot;Block&quot;; see <xref target="block"/>. &nbsp;The array may be empty if the file contains no data.</c>
</texttable>
</section>

<section anchor="filepreamble" title="&quot;FilePreamble&quot;">
<t>Information about data in the file. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>major-format-version</c><c>X</c><c>U</c><c>Unsigned integer "1". &nbsp;The
major version of the format used in the file. &nbsp;See <xref target="versioning"/>.</c>
<c></c><c></c><c></c><c></c>
<c>minor-format-version</c><c>X</c><c>U</c><c>Unsigned integer "0". &nbsp;The
minor version of the format used in the file. &nbsp;See <xref target="versioning"/>.</c>
<c></c><c></c><c></c><c></c>
<c>private-version</c><c></c><c>U</c><c>Version indicator available for private use by implementations.</c>
<c></c><c></c><c></c><c></c>
<c>block-parameters</c><c>X</c><c>A</c><c>Array of items of type &quot;BlockParameters&quot;. &nbsp;See <xref target="blockparameters"/>. &nbsp;The array must contain at least one entry. &nbsp;(The &quot;block-parameters-index&quot; item in each &quot;BlockPreamble&quot; indicates which array entry applies to that &quot;Block&quot;.)</c>
</texttable>

<section anchor="blockparameters" title="&quot;BlockParameters&quot;">
<t>Parameters relating to data storage and collection that apply to one or more items of type &quot;Block&quot;. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>storage-parameters</c><c>X</c><c>M</c><c>Parameters relating to data storage in a &quot;Block&quot; item. &nbsp;Map of type &quot;StorageParameters&quot;; see <xref target="storageparameters"/>.</c>
<c></c><c></c><c></c><c></c>
<c>collection-parameters</c><c></c><c>M</c><c>Parameters relating to collection of the data in a &quot;Block&quot; item. &nbsp;Map of type &quot;CollectionParameters&quot;; see <xref target="collectionparameters"/>.</c>
</texttable>

<section anchor="storageparameters" title="&quot;StorageParameters&quot;">
<t>Parameters relating to how data is stored in the items of type &quot;Block&quot;. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>ticks-per-second</c><c>X</c><c>U</c><c>Sub-second timing is recorded in ticks. &nbsp;This specifies the number of ticks in a second.</c>
<c></c><c></c><c></c><c></c>
<c>max-block-items</c><c>X</c><c>U</c><c>The maximum number of items stored in any of the arrays in a &quot;Block&quot; item (Q/R, Address/Event Count, or Malformed Message data items). &nbsp;An indication to a decoder of the resources needed to process the file.</c>
<c></c><c></c><c></c><c></c>
<c>storage-hints</c><c>X</c><c>M</c><c>Collection of hints as to which fields are omitted in the arrays that have optional fields. &nbsp;Map of type &quot;StorageHints&quot;. &nbsp;See <xref target="storagehints"/>.</c>
<c></c><c></c><c></c><c></c>
<c>opcodes</c><c>X</c><c>A</c><c>Array of OPCODES <xref target="opcodes"/> (unsigned integers, each in the range 0 to 15 inclusive) recorded by the collecting implementation. &nbsp;See <xref target="optional-rrs-and-opcodes"/>.</c>
<c></c><c></c><c></c><c></c>
<c>rr-types</c><c>X</c><c>A</c><c>Array of RR TYPEs <xref target="rrtypes"/> (unsigned integers, each in the range 0 to 65535 inclusive) recorded by the collecting implementation. &nbsp;See <xref target="optional-rrs-and-opcodes"/>.</c>
<c></c><c></c><c></c><c></c>
<c>storage-flags</c><c></c><c>U</c><c>Bit flags indicating attributes of stored data.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;1 if the data has been anonymized.</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;1 if the data is sampled data.</c>
<c></c><c></c><c></c><c>Bit 2. &nbsp;1 if the names have been normalized (converted to uniform case).</c>
<c></c><c></c><c></c><c></c>
<c>client-address -prefix-ipv4</c><c></c><c>U</c><c>IPv4 client address prefix length, in the range 1 to 32 inclusive. &nbsp;If specified, only the address prefix bits are stored.</c>
<c></c><c></c><c></c><c></c>
<c>client-address -prefix-ipv6</c><c></c><c>U</c><c>IPv6 client address prefix length, in the range 1 to 128 inclusive. &nbsp;If specified, only the address prefix bits are stored.</c>
<c></c><c></c><c></c><c></c>
<c>server-address -prefix-ipv4</c><c></c><c>U</c><c>IPv4 server address prefix length, in the range 1 to 32 inclusive. &nbsp;If specified, only the address prefix bits are stored.</c>
<c></c><c></c><c></c><c></c>
<c>server-address -prefix-ipv6</c><c></c><c>U</c><c>IPv6 server address prefix length, in the range 1 to 128 inclusive. &nbsp;If specified, only the address prefix bits are stored.</c>
<c></c><c></c><c></c><c></c>
<c>sampling-method</c><c></c><c>T</c><c>Information on the sampling method used. &nbsp;See <xref target="storage-flags"/>.</c>
<c></c><c></c><c></c><c></c>
<c>anonymization -method</c><c></c><c>T</c><c>Information on the anonymization method used. &nbsp;See <xref target="storage-flags"/>.</c>
</texttable>

<section anchor="storagehints" title="&quot;StorageHints&quot;">
<t>An indicator of which fields the collecting implementation omits in the maps with optional fields. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>query-response -hints</c><c>X</c><c>U</c><c>Hints indicating which &quot;QueryResponse&quot; fields are candidates for capture or omitted; see <xref target="queryresponse"/>. &nbsp;If a bit is unset, the field is omitted from the capture.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;time-offset</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;client-address-index</c>
<c></c><c></c><c></c><c>Bit 2. &nbsp;client-port</c>
<c></c><c></c><c></c><c>Bit 3. &nbsp;transaction-id</c>
<c></c><c></c><c></c><c>Bit 4. &nbsp;qr-signature-index</c>
<c></c><c></c><c></c><c>Bit 5. &nbsp;client-hoplimit</c>
<c></c><c></c><c></c><c>Bit 6. &nbsp;response-delay</c>
<c></c><c></c><c></c><c>Bit 7. &nbsp;query-name-index</c>
<c></c><c></c><c></c><c>Bit 8. &nbsp;query-size</c>
<c></c><c></c><c></c><c>Bit 9. &nbsp;response-size</c>
<c></c><c></c><c></c><c>Bit 10. &nbsp;response-processing-data</c>
<c></c><c></c><c></c><c>Bit 11. &nbsp;query-question-sections</c>
<c></c><c></c><c></c><c>Bit 12. &nbsp;query-answer-sections</c>
<c></c><c></c><c></c><c>Bit 13. &nbsp;query-authority-sections</c>
<c></c><c></c><c></c><c>Bit 14. &nbsp;query-additional-sections</c>
<c></c><c></c><c></c><c>Bit 15. &nbsp;response-answer-sections</c>
<c></c><c></c><c></c><c>Bit 16. &nbsp;response-authority-sections</c>
<c></c><c></c><c></c><c>Bit 17. &nbsp;response-additional-sections</c>
<c></c><c></c><c></c><c></c>
<c>query-response -signature-hints</c><c>X</c><c>U</c><c>Hints indicating which &quot;QueryResponseSignature&quot; fields are candidates for capture or omitted; see <xref target="queryresponsesignature"/>. &nbsp;If a bit is unset, the field is omitted from the capture.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;server-address</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;server-port</c>
<c></c><c></c><c></c><c>Bit 2. &nbsp;qr-transport-flags</c>
<c></c><c></c><c></c><c>Bit 3. &nbsp;qr-type</c>
<c></c><c></c><c></c><c>Bit 4. &nbsp;qr-sig-flags</c>
<c></c><c></c><c></c><c>Bit 5. &nbsp;query-opcode</c>
<c></c><c></c><c></c><c>Bit 6. &nbsp;dns-flags</c>
<c></c><c></c><c></c><c>Bit 7. &nbsp;query-rcode</c>
<c></c><c></c><c></c><c>Bit 8. &nbsp;query-class-type</c>
<c></c><c></c><c></c><c>Bit 9. &nbsp;query-qdcount</c>
<c></c><c></c><c></c><c>Bit 10. &nbsp;query-ancount</c>
<c></c><c></c><c></c><c>Bit 11. &nbsp;query-nscount</c>
<c></c><c></c><c></c><c>Bit 12. &nbsp;query-arcount</c>
<c></c><c></c><c></c><c>Bit 13. &nbsp;query-edns-version</c>
<c></c><c></c><c></c><c>Bit 14. &nbsp;query-udp-size</c>
<c></c><c></c><c></c><c>Bit 15. &nbsp;query-opt-rdata</c>
<c></c><c></c><c></c><c>Bit 16. &nbsp;response-rcode</c>
<c></c><c></c><c></c><c></c>
<c>rr-hints</c><c>X</c><c>U</c><c>Hints indicating which optional &quot;RR&quot; fields are candidates for capture or omitted; see <xref target="rr"/>. &nbsp;If a bit is unset, the field is omitted from the capture.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;ttl</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;rdata-index</c>
<c>other-data-hints</c><c>X</c><c>U</c><c>Hints indicating which other datatypes are omitted. &nbsp;If a bit is unset, the datatype is omitted from the capture.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;malformed-messages</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;address-event-counts</c>
</texttable>
</section>
</section>
</section>

<section anchor="collectionparameters" title="&quot;CollectionParameters&quot;">
<t>Parameters providing information regarding how data in the file was
collected (applicable for some, but not all, collection environments).
The values are informational only and serve as hints to downstream
analyzers as to the configuration of a collecting implementation. They
can provide context when interpreting what data is present&wj;/absent from
the capture but cannot necessarily be validated against the data
captured.
</t>
<t>These parameters have no default. If they do not appear, nothing can be inferred about their value.
</t>
<t>A map containing the following items:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>query-timeout</c><c></c><c>U</c><c>To be matched with a Query, a Response must arrive within this number of seconds.</c>
<c></c><c></c><c></c><c></c>
<c>skew-timeout</c><c></c><c>U</c><c>The network stack may report a Response before the corresponding Query. &nbsp;A Response is not considered to be missing a Query until after this many microseconds.</c>
<c></c><c></c><c></c><c></c>
<c>snaplen</c><c></c><c>U</c><c>Collect up to this many bytes per packet.</c>
<c></c><c></c><c></c><c></c>
<c>promisc</c><c></c><c>B</c><c>&quot;true&quot; if promiscuous mode <xref target="pcap-options"/> was enabled on the interface, &quot;false&quot; otherwise.</c>
<c></c><c></c><c></c><c></c>
<c>interfaces</c><c></c><c>A</c><c>Array of identifiers (of type text string) of the interfaces used for collection.</c>
<c></c><c></c><c></c><c></c>
<c>server-addresses</c><c></c><c>A</c><c>Array of server collection IP addresses (of type byte string). &nbsp;Hint for downstream analyzers; does not affect collection.</c>
<c></c><c></c><c></c><c></c>
<c>vlan-ids</c><c></c><c>A</c><c>Array of identifiers (of type unsigned integer, each in the range 1 to 4094 inclusive) of VLANs <xref target="IEEE802.1Q"/> selected for collection. &nbsp;VLAN IDs are unique only within an administrative domain.</c>
<c></c><c></c><c></c><c></c>
<c>filter</c><c></c><c>T</c><c>Filter for input, in &quot;tcpdump&quot; <xref target="pcap-filter"/> style.</c>
<c></c><c></c><c></c><c></c>
<c>generator-id</c><c></c><c>T</c><c>Implementation-specific human-readable string identifying the collection method.</c>
<c></c><c></c><c></c><c></c>
<c>host-id</c><c></c><c>T</c><c>String identifying the collecting host. &nbsp;Empty if converting an existing packet capture file.</c>
</texttable>
</section>
</section>

<section anchor="block" title="&quot;Block&quot;">
<t>Container for data with common collection and storage parameters. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>block-preamble</c><c>X</c><c>M</c><c>Overall information for the &quot;Block&quot; item. &nbsp;Map of type &quot;BlockPreamble&quot;; see <xref target="blockpreamble"/>.</c>
<c></c><c></c><c></c><c></c>
<c>block-statistics</c><c></c><c>M</c><c>Statistics about the &quot;Block&quot; item. &nbsp;Map of type &quot;BlockStatistics&quot;; see <xref target="blockstatistics"/>.</c>
<c></c><c></c><c></c><c></c>
<c>block-tables</c><c></c><c>M</c><c>The arrays containing data referenced by individual &quot;QueryResponse&quot; or &quot;MalformedMessage&quot; items. &nbsp;Map of type &quot;BlockTables&quot;; see <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>query-responses</c><c></c><c>A</c><c>Details of individual DNS Q/R data items. &nbsp;Array of items of type &quot;QueryResponse&quot;; see <xref target="queryresponse"/>. &nbsp;If present, the array must not be empty.</c>
<c></c><c></c><c></c><c></c>
<c>address-event -counts</c><c></c><c>A</c><c>Per-client counts of ICMP messages and TCP resets. &nbsp;Array of items of type &quot;AddressEventCount&quot;; see <xref target="addresseventcount"/>. &nbsp;If present, the array must not be empty.</c>
<c></c><c></c><c></c><c></c>
<c>malformed-messages</c><c></c><c>A</c><c>Details of malformed DNS messages. &nbsp;Array of items of type &quot;MalformedMessage&quot;; see <xref target="malformedmessage"/>. &nbsp;If present, the array must not be empty.</c>
</texttable>

<section anchor="blockpreamble" title="&quot;BlockPreamble&quot;">
<t>Overall information for a &quot;Block&quot; item. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>earliest-time</c><c>C</c><c>A</c><c>A timestamp (two unsigned integers,
&quot;Timestamp&quot;) for the earliest record in the &quot;Block&quot;
item. &nbsp;The first integer is the number of seconds since the POSIX epoch
<xref target="posix-time"/> (&quot;time_t&quot;), excluding leap seconds. &nbsp;The second integer is the number of ticks (see <xref target="storageparameters"/>) since the start of the second. &nbsp;This field is mandatory unless all block items containing a time offset from the start of the Block also omit that time offset.</c>
<c></c><c></c><c></c><c></c>
<c>block-parameters -index</c><c></c><c>U</c><c>The index of the item in the &quot;block-parameters&quot; array (in the &quot;file-preamble&quot; item) applicable to this block. &nbsp;If not present, index 0 is used. &nbsp;See <xref target="filepreamble"/>.</c>
</texttable>

<!-- [rfced] Section 7.5.1:  Please confirm that "Section 7.4.1" is
the correct citation here.  We could not find a relationship.

Original (best viewed with a fixed-point font such as Courier.
   The spelling of "premable" has been corrected):
 | block-parameters |   | U | The index of the item in the "block-   |
 | -index           |   |   | parameters" array (in the "file-       |
 |                  |   |   | premable" item) applicable to this     |
 |                  |   |   | block. If not present, index 0 is      |
 |                  |   |   | used. See Section 7.4.1.               |
-->

</section>

<section anchor="blockstatistics" title="&quot;BlockStatistics&quot;">
<t>Basic statistical information about a &quot;Block&quot; item. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>processed-messages</c><c></c><c>U</c><c>Total number of DNS messages processed from the input traffic stream during collection of data in this &quot;Block&quot; item.</c>
<c></c><c></c><c></c><c></c>
<c>qr-data-items</c><c></c><c>U</c><c>Total number of Q/R data items in this &quot;Block&quot; item.</c>
<c></c><c></c><c></c><c></c>
<c>unmatched-queries</c><c></c><c>U</c><c>Number of unmatched Queries in this &quot;Block&quot; item.</c>
<c></c><c></c><c></c><c></c>
<c>unmatched-responses</c><c></c><c>U</c><c>Number of unmatched Responses in this &quot;Block&quot; item.</c>
<c></c><c></c><c></c><c></c>
<c>discarded-opcode</c><c></c><c>U</c><c>Number of DNS messages processed from the input traffic stream during collection of data in this &quot;Block&quot; item but not recorded because their OPCODE is not in the list to be collected.</c>
<c></c><c></c><c></c><c></c>
<c>malformed-items</c><c></c><c>U</c><c>Number of malformed messages found in input for this &quot;Block&quot; item.</c>
</texttable>
</section>

<section anchor="blocktables" title="&quot;BlockTables&quot;">
<t>Map of arrays containing data referenced by individual &quot;QueryResponse&quot; or &quot;MalformedMessage&quot; items in this &quot;Block&quot;.
Each element is an array that, if present, must not be empty.
</t>
<t>An item in the &quot;qlist&quot; array contains indexes to values in the &quot;qrr&quot;
array. Therefore, if &quot;qlist&quot; is present, &quot;qrr&quot; must also be
present. Similarly, if &quot;rrlist&quot; is present, &quot;rr&quot; must also be present.
</t>
<t>The map contains the following items:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>ip-address</c><c></c><c>A</c><c>Array of IP addresses, in network byte order (of type byte string). &nbsp;If client or server address prefixes are set, only the address prefix bits are stored. &nbsp;Each string is therefore up to 4 bytes long for an IPv4 address, or up to 16 bytes long for an IPv6 address. &nbsp;See <xref target="storageparameters"/>.</c>
<c></c><c></c><c></c><c></c>
<c>classtype</c><c></c><c>A</c><c>Array of RR CLASS and TYPE information. &nbsp;Type is &quot;ClassType&quot;. &nbsp;See <xref target="classtype"/>.</c>
<c></c><c></c><c></c><c></c>
<c>name-rdata</c><c></c><c>A</c><c>Array where each entry is the contents of a
single NAME or RDATA in wire format (of type byte string). &nbsp;Note that
NAMEs, and labels within RDATA contents, are full domain names or labels; no
name compression (per <xref target="RFC1035"/>) is used on the individual names/labels within the format.</c>
<c></c><c></c><c></c><c></c>
<c>qr-sig</c><c></c><c>A</c><c>Array of Q/R data item signatures. &nbsp;Type is &quot;QueryResponseSignature&quot;. &nbsp;See <xref target="queryresponsesignature"/>.</c>
<c></c><c></c><c></c><c></c>
<c>qlist</c><c></c><c>A</c><c>Array of type &quot;QuestionList&quot;. &nbsp;A &quot;QuestionList&quot; is an array of unsigned integers, indexes to &quot;Question&quot; items in the &quot;qrr&quot; array.</c>
<c></c><c></c><c></c><c></c>
<c>qrr</c><c></c><c>A</c><c>Array of type &quot;Question&quot;. &nbsp;Each entry is the contents of a single question, where a question is the second or subsequent Question in a Query. &nbsp;See <xref target="question"/>.</c>
<c></c><c></c><c></c><c></c>
<c>rrlist</c><c></c><c>A</c><c>Array of type &quot;RRList&quot;. &nbsp;An &quot;RRList&quot; is an array of unsigned integers, indexes to &quot;RR&quot; items in the &quot;rr&quot; array.</c>
<c></c><c></c><c></c><c></c>
<c>rr</c><c></c><c>A</c><c>Array of type &quot;RR&quot;. &nbsp;Each entry is the contents of a single RR. &nbsp;See <xref target="rr"/>.</c>
<c></c><c></c><c></c><c></c>
<c>malformed-message -data</c><c></c><c>A</c><c>Array of the contents of malformed messages. &nbsp;Array of type &quot;MalformedMessageData&quot;. &nbsp;See <xref target="malformedmessagedata"/>.</c>
</texttable>

<section anchor="classtype" title="&quot;ClassType&quot;">
<t>RR CLASS and TYPE information. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>type</c><c>X</c><c>U</c><c>TYPE value <xref target="rrtypes"/>.</c>
<c></c><c></c><c></c><c></c>
<c>class</c><c>X</c><c>U</c><c>CLASS value <xref target="rrclasses"/>.</c>
</texttable>
</section>

<section anchor="queryresponsesignature" title="&quot;QueryResponseSignature&quot;">
<t>Elements of a Q/R data item that are often common between multiple
individual Q/R data items. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>server-address -index</c><c></c><c>U</c><c>The index in the item in the &quot;ip-address&quot; array of the server IP address. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>server-port</c><c></c><c>U</c><c>The server port.</c>
<c></c><c></c><c></c><c></c>
<c>qr-transport-flags</c><c>C</c><c>U</c><c>Bit flags describing the transport used to service the Query. &nbsp;Same definition as &quot;mm-transport-flags&quot; in <xref target="malformedmessagedata"/>, with an additional indicator for trailing bytes. &nbsp;See <xref target="cddl"/>.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;IP version. &nbsp;0 if IPv4, 1 if IPv6. &nbsp;See <xref target="ip-address-storage"/>.</c>
<c></c><c></c><c></c><c>Bits 1-4. &nbsp;Transport. &nbsp;4-bit unsigned value
where 0 = UDP, 1 = TCP, 2 = TLS, 3 = DTLS <xref target="RFC7858"/>, 4 = DoH
<xref target="RFC8484"/>. &nbsp;("DoH" stands for DNS over HTTPS.) &nbsp;Values 5-15 are reserved for future use.</c>
<c></c><c></c><c></c><c>Bit 5. &nbsp;1 if trailing bytes in Query packet. &nbsp;See <xref target="trailing-bytes"/>.</c>
<c></c><c></c><c></c><c></c>
<c>qr-type</c><c></c><c>U</c><c>Type of Query/Response transaction.</c>
<c></c><c></c><c></c><c>0 = Stub. &nbsp;A Query from a stub resolver.</c>
<c></c><c></c><c></c><c>1 = Client. &nbsp;An incoming Query to a recursive resolver.</c>
<c></c><c></c><c></c><c>2 = Resolver. &nbsp;A Query sent from a recursive resolver to an authoritative resolver.</c>
<c></c><c></c><c></c><c>3 = Authoritative. &nbsp;A Query to an authoritative resolver.</c>
<c></c><c></c><c></c><c>4 = Forwarder. &nbsp;A Query sent from a recursive resolver to an upstream recursive resolver.</c>
<c></c><c></c><c></c><c>5 = Tool. &nbsp;A Query sent to a server by a server tool.</c>
<c></c><c></c><c></c><c></c>
<c>qr-sig-flags</c><c></c><c>U</c><c>Bit flags explicitly indicating attributes of the message pair represented by this Q/R data item (not all attributes may be recorded or deducible).</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;1 if a Query was present.</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;1 if a Response was present.</c>
<c></c><c></c><c></c><c>Bit 2. &nbsp;1 if a Query was present and it had an OPT RR.</c>
<c></c><c></c><c></c><c>Bit 3. &nbsp;1 if a Response was present and it had an OPT RR.</c>
<c></c><c></c><c></c><c>Bit 4. &nbsp;1 if a Query was present but had no Question.</c>
<c></c><c></c><c></c><c>Bit 5. &nbsp;1 if a Response was present but had no Question (only one query-name-index is stored per Q/R data item).</c>
<c></c><c></c><c></c><c></c>
<c>query-opcode</c><c></c><c>U</c><c>Query OPCODE.</c>
<c></c><c></c><c></c><c></c>
<c>qr-dns-flags</c><c></c><c>U</c><c>Bit flags with values from the Query and Response DNS flags. &nbsp;Flag values are 0 if the Query or Response is not present.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;Query Checking Disabled (CD).</c>
<c></c><c></c><c></c><c>Bit 1. &nbsp;Query Authenticated Data (AD).</c>
<c></c><c></c><c></c><c>Bit 2. &nbsp;Query reserved (Z).</c>
<c></c><c></c><c></c><c>Bit 3. &nbsp;Query Recursion Available (RA).</c>
<c></c><c></c><c></c><c>Bit 4. &nbsp;Query Recursion Desired (RD).</c>
<c></c><c></c><c></c><c>Bit 5. &nbsp;Query TrunCation (TC).</c>
<c></c><c></c><c></c><c>Bit 6. &nbsp;Query Authoritative Answer (AA).</c>
<c></c><c></c><c></c><c>Bit 7. &nbsp;Query DNSSEC answer OK (DO).</c>
<c></c><c></c><c></c><c>Bit 8. &nbsp;Response Checking Disabled (CD).</c>
<c></c><c></c><c></c><c>Bit 9. &nbsp;Response Authenticated Data (AD).</c>
<c></c><c></c><c></c><c>Bit 10. &nbsp;Response reserved (Z).</c>
<c></c><c></c><c></c><c>Bit 11. &nbsp;Response Recursion Available (RA).</c>
<c></c><c></c><c></c><c>Bit 12. &nbsp;Response Recursion Desired (RD).</c>
<c></c><c></c><c></c><c>Bit 13. &nbsp;Response TrunCation (TC).</c>
<c></c><c></c><c></c><c>Bit 14. &nbsp;Response Authoritative Answer (AA).</c>
<c></c><c></c><c></c><c></c>
<c>query-rcode</c><c></c><c>U</c><c>Query RCODE. &nbsp;If the Query contains OPT <xref target="RFC6891"/>, this value incorporates any EXTENDED-RCODE value<xref target="rcodes"/>.</c>
<c></c><c></c><c></c><c></c>
<c>query-classtype -index</c><c></c><c>U</c><c>The index to the item in the &quot;classtype&quot; array of the CLASS and TYPE of the first Question. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>query-qd-count</c><c></c><c>U</c><c>The QDCOUNT in the Query, or Response if no Query present.</c>
<c></c><c></c><c></c><c></c>
<c>query-an-count</c><c></c><c>U</c><c>Query ANCOUNT.</c>
<c></c><c></c><c></c><c></c>
<c>query-ns-count</c><c></c><c>U</c><c>Query NSCOUNT.</c>
<c></c><c></c><c></c><c></c>
<c>query-ar-count</c><c></c><c>U</c><c>Query ARCOUNT.</c>
<c></c><c></c><c></c><c></c>
<c>edns-version</c><c></c><c>U</c><c>The Query EDNS version. &nbsp;("EDNS"
stands for Extension Mechanisms for DNS.)</c>
<c></c><c></c><c></c><c></c>
<c>udp-buf-size</c><c></c><c>U</c><c>The Query EDNS sender's UDP payload size.</c>
<c></c><c></c><c></c><c></c>
<c>opt-rdata-index</c><c></c><c>U</c><c>The index in the &quot;name-rdata&quot; array  of the OPT RDATA. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>response-rcode</c><c></c><c>U</c><c>Response RCODE. &nbsp;If the Response contains OPT <xref target="RFC6891"/>, this value incorporates any EXTENDED_RCODE_VALUE <xref target="rcodes"/>.</c>
</texttable>

<!-- [rfced] Section 7.5.3.2:  What does "EXTENDED_RCODE_VALUE" 
refer to? It does not appear in the DNS RCODEs registry [rcodes] or 
in any published RFC.  Will these table entries be clear to readers?

Original (best viewed with a fixed-point font such as Courier):
 | query-rcode        |   | U | Query RCODE. If the Query contains   |
 |                    |   |   | OPT [RFC6891], this value            |
 |                    |   |   | incorporates any                     |
 |                    |   |   | EXTENDED_RCODE_VALUE [rcodes].       |
...
 | response-rcode     |   | U | Response RCODE. If the Response      |
 |                    |   |   | contains OPT [RFC6891], this value   |
 |                    |   |   | incorporates any                     |
 |                    |   |   | EXTENDED_RCODE_VALUE [rcodes].       |
-->

</section>

<section anchor="question" title="&quot;Question&quot;">
<t>Details on individual Questions in a Question section. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>name-index</c><c>X</c><c>U</c><c>The index in the &quot;name-rdata&quot; array of the QNAME. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>classtype-index</c><c>X</c><c>U</c><c>The index in the &quot;classtype&quot; array of the CLASS and TYPE of the Question. &nbsp;See <xref target="blocktables"/>.</c>
</texttable>
</section>

<section anchor="rr" title="&quot;RR&quot;">
<t>Details on individual RRs in RR sections. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>name-index</c><c>X</c><c>U</c><c>The index in the &quot;name-rdata&quot; array of the NAME. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>classtype-index</c><c>X</c><c>U</c><c>The index in the &quot;classtype&quot; array of the CLASS and TYPE of the RR. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>ttl</c><c></c><c>U</c><c>The RR Time to Live.</c>
<c></c><c></c><c></c><c></c>
<c>rdata-index</c><c></c><c>U</c><c>The index in the &quot;name-rdata&quot; array of the RR RDATA. &nbsp;See <xref target="blocktables"/>.</c>
</texttable>
</section>

<section anchor="malformedmessagedata" title="&quot;MalformedMessageData&quot;">
<t>Details on malformed message items in this &quot;Block&quot; item. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>server-address -index</c><c></c><c>U</c><c>The index in the &quot;ip-address&quot; array of the server IP address. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>server-port</c><c></c><c>U</c><c>The server port.</c>
<c></c><c></c><c></c><c></c>
<c>mm-transport-flags</c><c>C</c><c>U</c><c>Bit flags describing the transport used to service the Query. &nbsp;See <xref target="ip-address-storage"/>.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;IP version. &nbsp;0 if IPv4, 1 if IPv6.</c>
<c></c><c></c><c></c><c>Bits 1-4. &nbsp;Transport. &nbsp;4-bit unsigned value where 0 = UDP, 1 = TCP, 2 = TLS, 3 = DTLS <xref target="RFC7858"/>, 4 = DoH <xref target="RFC8484"/>. &nbsp;Values 5-15 are reserved for future use.</c>
<c></c><c></c><c></c><c></c>
<c>mm-payload</c><c></c><c>S</c><c>The payload (raw bytes) of the DNS message.</c>
</texttable>
</section>
</section>
</section>

<section anchor="queryresponse" title="&quot;QueryResponse&quot;">
<t>Details on individual Q/R data items.
</t>
<t>Note that there is no requirement that the elements of the &quot;query&nbhy;responses&quot; array are presented in strict chronological order.
</t>
<t>A map containing the following items:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>time-offset</c><c></c><c>U</c><c>Q/R timestamp as an offset in ticks (see <xref target="storageparameters"/>) from &quot;earliest-time&quot;. &nbsp;The timestamp is the timestamp of the Query, or the Response if there is no Query.</c>
<c></c><c></c><c></c><c></c>
<c>client-address-index</c><c></c><c>U</c><c>The index in the &quot;ip-address&quot; array of the client IP address. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>client-port</c><c></c><c>U</c><c>The client port.</c>
<c></c><c></c><c></c><c></c>
<c>transaction-id</c><c></c><c>U</c><c>DNS transaction identifier.</c>
<c></c><c></c><c></c><c></c>
<c>qr-signature-index</c><c></c><c>U</c><c>The index in the &quot;qr-sig&quot; array of the &quot;QueryResponseSignature&quot; item. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>client-hoplimit</c><c></c><c>U</c><c>The IPv4 TTL or IPv6 Hoplimit from the Query packet.</c>
<c></c><c></c><c></c><c></c>
<c>response-delay</c><c></c><c>I</c><c>The time difference between Query and Response, in ticks. &nbsp;See <xref target="storageparameters"/>. &nbsp;Only present if there is a Query and a Response. &nbsp;The delay can be negative if the network stack/capture library returns packets out of order.</c>
<c></c><c></c><c></c><c></c>
<c>query-name-index</c><c></c><c>U</c><c>The index in the &quot;name-rdata&quot; array of the item containing the QNAME for the first Question. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>query-size</c><c></c><c>U</c><c>DNS Query message size (see below).</c>
<c></c><c></c><c></c><c></c>
<c>response-size</c><c></c><c>U</c><c>DNS Response message size (see below).</c>
<c></c><c></c><c></c><c></c>
<c>response-processing -data</c><c></c><c>M</c><c>Data on Response processing. &nbsp;Map of type &quot;ResponseProcessingData&quot;. &nbsp;See <xref target="responseprocessingdata"/>.</c>
<c></c><c></c><c></c><c></c>
<c>query-extended</c><c></c><c>M</c><c>Extended Query data. &nbsp;Map of type &quot;QueryResponseExtended&quot;. &nbsp;See <xref target="queryresponseextended"/>.</c>
<c></c><c></c><c></c><c></c>
<c>response-extended</c><c></c><c>M</c><c>Extended Response data. &nbsp;Map of type &quot;QueryResponseExtended&quot;. &nbsp;See <xref target="queryresponseextended"/>.</c>
</texttable>
<t>The &quot;query-size&quot; and &quot;response-size&quot; fields hold the DNS message
size. For UDP, this is the size of the UDP payload that contained the
DNS message. For TCP, it is the size of the DNS message as specified in
the two-byte message length header. Trailing bytes in UDP Queries are
routinely observed in traffic to authoritative servers, and this value
allows a calculation of how many trailing bytes were present.
</t>

<section anchor="responseprocessingdata" title="&quot;ResponseProcessingData&quot;">
<t>Information on the server processing that produced the Response. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>bailiwick-index</c><c></c><c>U</c><c>The index in the &quot;name-rdata&quot; array of the owner name for the Response bailiwick. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>processing-flags</c><c></c><c>U</c><c>Flags relating to Response processing.</c>
<c></c><c></c><c></c><c>Bit 0. &nbsp;1 if the Response came from cache.</c>
</texttable>
</section>

<section anchor="queryresponseextended" title="&quot;QueryResponseExtended&quot;">
<t>Extended data on the Q/R data item.
</t>
<t>Each item in the map is present only if collection of the relevant details is configured.
</t>
<t>A map containing the following items:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>question-index</c><c></c><c>U</c><c>The index in the &quot;qlist&quot; array of the entry listing any second and subsequent Questions in the Question section for the Query or Response. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>answer-index</c><c></c><c>U</c><c>The index in the &quot;rrlist&quot; array of the entry listing the Answer RR sections for the Query or Response. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>authority-index</c><c></c><c>U</c><c>The index in the &quot;rrlist&quot; array of the entry listing the Authority RR sections for the Query or Response. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>additional-index</c><c></c><c>U</c><c>The index in the &quot;rrlist&quot;
array of the entry listing the Additional RR sections for the Query or
Response. &nbsp;See <xref target="blocktables"/>. &nbsp;Note that Query OPT RR
data can optionally be stored in the QuerySignature.</c>
</texttable>
</section>
</section>

<section anchor="addresseventcount" title="&quot;AddressEventCount&quot;">
<t>Counts of various IP-related events relating to traffic with
individual client addresses. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>ae-type</c><c>X</c><c>U</c><c>The type of event. &nbsp;The following event types are currently defined:</c>
<c></c><c></c><c></c><c>0. &nbsp;TCP reset.</c>
<c></c><c></c><c></c><c>1. &nbsp;ICMP time exceeded.</c>
<c></c><c></c><c></c><c>2. &nbsp;ICMP destination unreachable.</c>
<c></c><c></c><c></c><c>3. &nbsp;ICMPv6 time exceeded.</c>
<c></c><c></c><c></c><c>4. &nbsp;ICMPv6 destination unreachable.</c>
<c></c><c></c><c></c><c>5. &nbsp;ICMPv6 packet too big.</c>
<c></c><c></c><c></c><c></c>
<c>ae-code</c><c></c><c>U</c><c>A code relating to the event. &nbsp;For ICMP or ICMPv6 events, this MUST be the ICMP <xref target="RFC0792"/> or ICMPv6 <xref target="RFC4443"/> code. &nbsp;For other events, the contents are undefined.</c>
<c></c><c></c><c></c><c></c>
<c>ae-address-index</c><c>X</c><c>U</c><c>The index in the &quot;ip-address&quot; array of the client address. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>ae-count</c><c>X</c><c>U</c><c>The number of occurrences of this event during the Block collection period.</c>
</texttable>
</section>

<section anchor="malformedmessage" title="&quot;MalformedMessage&quot;">
<t>Details of malformed messages. A map containing the following:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="center">M</ttcol>
<ttcol align="center">T</ttcol>
<ttcol align="left">Description</ttcol>

<c>time-offset</c><c></c><c>U</c><c>Message timestamp as an offset in ticks (see <xref target="storageparameters"/>) from &quot;earliest-time&quot;.</c>
<c></c><c></c><c></c><c></c>
<c>client-address-index</c><c></c><c>U</c><c>The index in the &quot;ip-address&quot; array of the client IP address. &nbsp;See <xref target="blocktables"/>.</c>
<c></c><c></c><c></c><c></c>
<c>client-port</c><c></c><c>U</c><c>The client port.</c>
<c></c><c></c><c></c><c></c>
<c>message-data-index</c><c></c><c>U</c><c>The index in the &quot;malformed-message-data&quot; array of the message data for this message. &nbsp;See <xref target="blocktables"/>.</c>
</texttable>
</section>
</section>

<section anchor="versioning" title="Versioning">
<t>The C-DNS File Preamble includes a file Format Version; a major and minor
version number are required fields. This document defines version 1.0 of the
C-DNS specification. This section describes the intended use of these version
numbers in future specifications.
</t>
<t>It is noted that version 1.0 includes many optional fields; therefore,
consumers of version 1.0 should be inherently robust to parsing files with
variable data content.
</t>
<t>Within a major version, a new minor version MUST be a strict superset of the
previous minor version, with no semantic changes to existing fields. New keys
MAY be added to existing maps, and new maps MAY be added. A consumer capable of
reading a particular major.minor version MUST also be capable of reading all
previous minor versions of the same major version. It SHOULD also be capable of
parsing all subsequent minor versions, ignoring any keys or maps that it does
not recognize.
</t>
<t>A new major version indicates changes to the format that are not backwards
compatible with previous major versions. A consumer capable of only reading a
particular major version (greater than 1) is neither required nor expected to
be capable of reading a previous major version.
</t>
</section>

<section anchor="cdns-to-pcap" title="C-DNS to PCAP">
<t>It is possible to reconstruct PCAP files from the C-DNS format in a lossy fashion.
Some of the issues with reconstructing both the DNS payload and the
full packet stream are outlined here.
</t>
<t>The reconstruction depends on whether or not all the optional sections
of both the Query and Response were captured in the C-DNS file.
Clearly, if they were not all captured, the reconstruction will be imperfect.
</t>
<t>Even if all sections of the Response were captured, one cannot reconstruct the DNS
Response payload exactly, due to the fact that some DNS names in the message on the wire
may have been compressed.
<xref target="name-compression"/> discusses this in more detail.
</t>
<t>Some transport
information is not captured in the C-DNS format. For example, the following aspects
of the original packet stream cannot be reconstructed from the C-DNS format:
</t>
<t>
<list style="symbols">
<t>IP fragmentation</t>
<t>TCP stream information:
<list style="symbols">
<t>Multiple DNS messages may have been sent in a single TCP segment</t>
<t>A DNS payload may have been split across multiple TCP segments</t>
<t>Multiple DNS messages may have been sent on a single TCP session</t>
</list></t>
<t>Malformed DNS messages if the wire format is not recorded</t>
<t>Any non-DNS messages that were in the original packet stream, e.g., ICMP</t>
</list>
</t>
<t>Simple assumptions can be made on the reconstruction: fragmented and DNS-over-TCP messages
can be reconstructed into single packets, and a single TCP session can be constructed
for each TCP packet.
</t>
<t>Additionally, if malformed messages and non-DNS packets are captured separately,
they can be merged with packet captures reconstructed from C-DNS to produce a more complete
packet stream.
</t>

<section anchor="name-compression" title="Name Compression">
<t>All the names stored in the C-DNS format are full domain names;
no name compression (per <xref target="RFC1035"/>) is used
on the individual names within the format. Therefore, when reconstructing a packet,
name compression must be used in order to reproduce the on-the-wire representation of the
packet.
</t>
<t>Name compression per <xref target="RFC1035"/> works by substituting trailing sections of a name with a
reference back to the occurrence of those sections earlier in the message.
Not all name server software uses the same algorithm when compressing domain names
within the Responses. Some attempt maximum recompression
at the expense of runtime resources, others use heuristics to balance compression
and speed, and others use different rules for what is a valid compression target.
</t>
<t>This means that Responses to the
same question from different name server software that match in terms of DNS payload
content (header, counts, RRs with name compression removed) do
not necessarily match byte for byte on the wire.
</t>
<t>Therefore, it is not possible to ensure that the DNS Response payload is reconstructed
byte for byte from C-DNS data. However, it can at least, in principle, be reconstructed to have the correct payload
length (since the original Response length is captured) if there is enough knowledge of the
commonly implemented name compression algorithms. For example, a simplistic approach would be
to try each algorithm in turn
to see if it reproduces the original length, stopping at the first match. This would not
guarantee that the correct algorithm has been used, as it is possible to match the length
whilst still not matching the on-the-wire bytes; however, without further
information added to the C-DNS data, this is the best that can be achieved.
</t>
<t><xref target="dns-name-compression-example"/> presents an example of two
different compression algorithms used by well-known name server software.
</t>
</section>
</section>

<section anchor="data-collection" title="Data Collection">
<t>This section describes a non-normative proposed algorithm for the
processing of a captured stream of DNS Queries and Responses and production of
a stream of Q/R data items, matching Queries and Responses where
possible.
</t>
<t>For the purposes of this discussion, it is assumed that the input has been preprocessed such that:
</t>
<t>
<list style="numbers">
<t>All IP fragmentation reassembly, TCP stream reassembly, and so&nbsp;on, have already been performed.</t>
<t>Each message is associated with transport metadata required to generate the Primary ID (see <xref target="primary-id"/>).</t>
<t>Each message has a well-formed DNS Header of 12 bytes, and (if present) the first Question in the Question section can be
parsed to generate the Secondary ID (see below). As noted earlier, this requirement can result in a malformed Query being
removed in the preprocessing stage, but the correctly formed Response with RCODE of FORMERR being present.</t>
</list>
</t>
<t>DNS messages are processed in the order they are delivered to the implementation.
</t>
<t>It should be noted that packet capture libraries do not necessarily provide packets in strict chronological order.
This can, for example, arise on multi-core platforms where packets arriving at a network device
are processed by different cores. On systems where this behavior has been observed, the timestamps associated
with each packet are consistent; Queries always have a timestamp prior to the Response timestamp.
However, the order in which these packets appear in the packet capture stream is not necessarily
strictly chronological; a Response can appear in the capture stream before the Query that provoked
the Response. For this discussion, this non&nbhy;chronological delivery is termed &quot;skew&quot;.
</t>
<t>In the presence of skew, Response packets can arrive for matching before the corresponding Query. To avoid
generating false instances of Responses without a matching Query, and Queries without a matching Response,
the matching algorithm must take the possibility of skew into account.
</t>

<section anchor="matching-algorithm" title="Matching Algorithm">
<t>A schematic representation of the algorithm for matching Q/R data items is shown
in <xref target="fig3"/>. It takes individual DNS Query or Response messages
as input, and it outputs matched Q/R data items. The numbers in the figure identify
matching operations listed in <xref target="table1"/>. Specific details of the
algorithm -- for example, queues, timers, and identifiers -- are given in the
following sections.
</t>

<figure align="center" title="Query/Response Matching Algorithm" anchor="fig3"><artwork align="center">
                   .----------------------.
                   | Process next message |&lt;------------------+
                   `----------------------'                   |
                               |                              |
               +------------------------------+               |
               | Generate message identifiers |               |
               +------------------------------+               |
                               |                              |
                      Response | Query                        |
               +--------------&lt; &gt;---------------+             |
               |                                |             |
     +--------------------+           +--------------------+  |
     | Find earliest QR   |           | Create QR item (2) |  |
     | item in OFIFO (1)  |           +--------------------+  |
     +--------------------+                     |             |
                |                        +---------------+    |
          Match | No match               | Append new QR |    |
      +--------&lt; &gt;------+                | item to OFIFO |    |
      |                 |                +---------------+    |
+-----------+      +--------+                   |             |
| Update QR |      | Add to |          +-------------------+  |
| item (3)  |      | RFIFO  |          | Find earliest QR  |  |
+-----------+      +--------+          | item in RFIFO (1) |  |
      |                 |              +-------------------+  |
      +-----------------+                       |             |
                |                               |             |
                |     +----------------+  Match | No match    |
                |     | Remove R       |-------&lt; &gt;-----+      |
                |     | from RFIFO (3) |               |      |
                |     +----------------+               |      |
                |              |                       |      |
                +--------------+-----------------------+      |
                               |                              |
        +----------------------------------------------+      |
        | Update all timed-out (QT) OFIFO QR items (4) |      |
        +----------------------------------------------+      |
                               |                              |
               +--------------------------------+             |
               | Remove all timed-out (ST) R    |             |
               | from RFIFO, create QR item (5) |             |
               +--------------------------------+             |
           ____________________|_______________________       |
          /                                            /      |
         /  Remove all consecutive done entries from  /-------+
        /   front of OFIFO for further processing    /
       /____________________________________________/

       OFIFO = output FIFO containing Q/R data items (Section 10.6)
       RFIFO = Response FIFO containing unmatched Response items (Section 10.6)
       QT = Query Timeout (Section 10.3)
       ST = Skew Timeout (Section 10.3)
</artwork></figure>

<!-- [rfced] Section 10.1:  For ease of the reader, we defined
"OFIFO," "RFIFO," "QT," and "ST" at the end of Figure 3.  Please let
us know any objections.

Original:
 [no text]

Currently:
 OFIFO = output FIFO containing Q/R items (Section 10.6)
 RFIFO = FIFO holding responses (Section 10.6)
 QT = Query Timeout (Section 10.3)
 ST = Skew Timeout (Section 10.3)
-->

<texttable title="Operations Used in the Matching Algorithm" anchor="table1">
<ttcol align="left">Reference</ttcol>
<ttcol align="left">Operation</ttcol>

<c>(1)</c><c>Find earliest QR item in FIFO where:</c>
<c></c><c>* QR.done = false</c>
<c></c><c>* QR.Q.PrimaryID == R.PrimaryID</c>
<c></c><c>and, if both QR.Q and R have SecondaryID:</c>
<c></c><c>* QR.Q.SecondaryID == R.SecondaryID</c>
<c></c><c></c>
<c>(2)</c><c>Set:</c>
<c></c><c>QR.Q := Q</c>
<c></c><c>QR.R := nil</c>
<c></c><c>QR.done := false</c>
<c></c><c></c>
<c>(3)</c><c>Set:</c>
<c></c><c>QR.R := R</c>
<c></c><c>QR.done := true</c>
<c></c><c></c>
<c>(4)</c><c>Set:</c>
<c></c><c>QR.done := true</c>
<c></c><c></c>
<c>(5)</c><c>Set:</c>
<c></c><c>QR.Q := nil</c>
<c></c><c>QR.R := R</c>
<c></c><c>QR.done := true</c>
</texttable>
</section>

<section anchor="message-identifiers" title="Message Identifiers">

<section anchor="primary-id" title="Primary ID (Required)">
<t>A Primary ID is constructed for each message. It is composed of the following data:
</t>
<t>
<list style="numbers">
<t>Source IP Address</t>
<t>Destination IP Address</t>
<t>Source Port</t>
<t>Destination Port</t>
<t>Transport</t>
<t>DNS Message ID</t>
</list>
</t>
</section>

<section anchor="secondary-id" title="Secondary ID (Optional)">
<t>If present, the first Question in the Question section is used as a
Secondary ID for each message. Note that there may be well-formed DNS Queries
that have a QDCOUNT of 0, and some Responses may have a QDCOUNT of 0 (for
example, Responses with RCODE=FORMERR or NOTIMP). In this case, the
Secondary ID is not used in matching.
</t>
</section>
</section>

<section anchor="algorithm-parameters" title="Algorithm Parameters">
<t>
<list style="numbers">
<t>Query Timeout (QT). A Query arrives with timestamp t1. If no Response
matching that Query has arrived before other input arrives timestamped later
than (t1 + QT), a Q/R data item containing only a Query is
recorded. The QT value is typically on the order of 5 seconds.</t>
<t>Skew Timeout (ST). A Response arrives with timestamp t2. If a Response has
not been matched by a Query before input arrives timestamped later than (t2 +
ST), a Q/R data item containing only a Response is recorded. The ST
value is typically a few microseconds.</t>
</list>
</t>
</section>

<section anchor="algorithm-requirements" title="Algorithm Requirements">
<t>The algorithm is designed to handle the following input data:
</t>
<t>
<list style="numbers">
<t>Multiple Queries with the same Primary ID (but different Secondary ID) arriving before any Responses for these Queries are&nbsp;seen.</t>
<t>Multiple Queries with the same Primary and Secondary ID arriving before any Responses for these Queries are seen.</t>
<t>Queries for which no later Response can be found within the specified timeout.</t>
<t>Responses for which no previous Query can be found within the specified timeout.</t>
</list>
</t>
</section>

<section anchor="algorithm-limitations" title="Algorithm Limitations">
<t>For cases 1 and 2 listed in the above requirements, it is not possible to unambiguously match Queries with Responses.
This algorithm chooses to match to the earliest Query with the correct Primary and Secondary ID.
</t>
</section>

<section anchor="workspace" title="Workspace">
<t>The algorithm employs two FIFO queues:
</t>
<t>
<list style="symbols">
<t>OFIFO: an output FIFO containing Q/R data items in chronological order.</t>
<t>RFIFO: a FIFO holding Responses without a matching Query in order of
arrival.</t>
</list>
</t>
</section>

<section anchor="output" title="Output">
<t>The output is a list of Q/R data items. Both the Query and Response
elements are optional in these items; therefore, Q/R data items have one of
three types of content:
</t>
<t>
<list style="numbers">
<t>A matched pair of Query and Response messages</t>
<t>A Query message with no Response</t>
<t>A Response message with no Query</t>
</list>
</t>
<t>The timestamp of a list item is that of the Query for cases 1 and 2 and that of the Response for case 3.
</t>
</section>

<section anchor="post-processing" title="Post-Processing">
<t>When ending a capture, all items in the RFIFO are timed out
immediately, generating Response only entries to the OFIFO.
These and all other remaining entries in the OFIFO
should be treated as timed-out Queries.

<!-- [rfced] Section 10.8:  Should "responses FIFO" be "RFIFO," and
should "Q/R data item FIFO" be "OFIFO" here?

Original:
 When ending capture, all items in the responses FIFO are timed out
 immediately, generating response-only entries to the Q/R data item
 FIFO.  These and all other remaining entries in the Q/R data item
 FIFO should be treated as timed out Queries.

Possibly:
 When ending a capture, all items in the RFIFO are timed out
 immediately, generating response-only entries to the OFIFO.
 These and all other remaining entries in the OFIFO should be
 treated as timed-out queries. -->

</t>
</section>
</section>

<section anchor="implementation-guidance" title="Implementation Guidance">
<t>Whilst this document makes no specific recommendations with respect to
"Canonical CBOR" (see Section&nbsp;3.9 of <xref target="RFC7049"/>), the
following guidance may be of use to implementers.
</t>
<t>Adherence to the first two rules given in Section&nbsp;3.9 of <xref target="RFC7049"/> will minimize file sizes.
</t>
<t>Adherence to the last two rules given in Section&nbsp;3.9 of <xref
target="RFC7049"/> for all maps and arrays would unacceptably constrain
implementations -- for example, in the use case of real-time data collection in
constrained environments where outputting Block Tables after Q/R
data items and allowing indefinite-length maps and arrays could reduce memory
requirements.
</t>

<section anchor="optional-data" title="Optional Data">
<t>When decoding C-DNS data, some of the items required for a particular
function that the consumer wishes to perform may be missing. Consumers should
consider providing configurable default values to be used in place of the
missing values in their output.
</t>
</section>

<section anchor="trailing-bytes" title="Trailing Bytes">
<t>A DNS Query message in a UDP or TCP payload can be followed by some additional (spurious) bytes, which are not stored in C-DNS.
</t>
<t>When DNS traffic is sent over TCP, each message is prefixed with a
two&nbhy;byte length field, which gives the message length, excluding the
two&nbhy;byte length field. In this context, trailing bytes can occur in two
circumstances, with different results:
</t>
<t>
<list style="numbers">
<t>The number of bytes consumed by fully parsing the message is less than the
number of bytes given in the length field (i.e., the length field is incorrect
and too large). In this case, the surplus bytes are considered trailing bytes
in a manner analogous to UDP and recorded as such. If only this case occurs,
it is possible to process a packet containing multiple DNS messages where one
or more have trailing bytes.</t>
<t>There are surplus bytes between the end of a well-formed message and the
start of the length field for the next message. In this case, the first of the
surplus bytes will be processed as the first byte of the next length field,
and parsing will proceed from there, almost certainly leading to the next and
any subsequent messages in the packet being considered malformed. This will
not generate a trailing-bytes record for the processed well-formed
message.</t>
</list>
</t>
</section>

<section anchor="limiting-collection-of-rdata" title="Limiting Collection of RDATA">

<!-- [rfced] What does "large XFR records" refer to here?
Does it refer to the RR types, e.g., "large AXFR or IXFR data"?
Or, would it be clear written out as "large transfer records"?

Original:
   Implementations should consider providing a configurable maximum
   RDATA size for capture, for example, to avoid memory issues when
   confronted with large XFR records.
--> 

<t>Implementations should consider providing a configurable maximum RDATA size
for captures -- for example, to avoid memory issues when confronted with large
zone transfer records.
</t>
</section>

<section anchor="timestamps" title="Timestamps">
<t>The preamble to each block includes a timestamp of the earliest record in
the Block. As described in <xref target="blockpreamble"/>, the timestamp is an
array of two unsigned integers. The first is a POSIX &quot;time_t&quot; <xref
target="posix-time"/>. Consumers of C-DNS should be aware of this, as it
excludes leap seconds and therefore may cause minor anomalies in the data,
e.g., when calculating Query throughput.
</t>
</section>
</section>

<section anchor="iana-considerations" title="IANA Considerations">
<t>IANA has created a registry &quot;C-DNS DNS Capture Format&quot; 
containing the subregistries defined in
Sections&nbsp;<xref target="transport-types" format="counter"/> to
<xref target="addressevent-types" format="counter"/> inclusive.
</t>
<t>In all cases, new entries may be added to the subregistries by Expert Review
as defined in <xref target="RFC8126"/>. Experts are expected to exercise their
own expert judgment and should consider the following general guidelines in
addition to any provided guidelines that are particular to a subregistry.
</t>
<t>
<list style="symbols">
<t>There should be a real and compelling use for any new value.</t>
<t>Values assigned should be carefully chosen to minimize storage requirements for common cases.</t>
</list>
</t>

<section anchor="transport-types" title="Transport Types">
<t>IANA has created a registry &quot;C-DNS Transports&quot; of C-DNS transport
type identifiers. The primary purpose of this registry is to provide unique
identifiers for all transports used for DNS Queries.
</t>

<t>The following note is included in this registry: &quot;In version 1.0 of
C-DNS [RFC8618], there is a field to identify the type of DNS transport. This
field is 4 bits in size.&quot;
</t>
<t>The initial contents of the
registry are as follows. See Sections&nbsp;<xref
target="queryresponsesignature" format="counter"/> and
<xref target="malformedmessagedata" format="counter"/> of
this document:
</t>

<!-- Note: Values below are also in Sections 7.5.3.2 and 7.5.3.5 -->

<texttable>
<ttcol align="center">Identifier</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Reference</ttcol>

<c>0</c><c>UDP</c><c>RFC 8618</c>
<c>1</c><c>TCP</c><c>RFC 8618</c>
<c>2</c><c>TLS</c><c>RFC 8618</c>
<c>3</c><c>DTLS</c><c>RFC 8618</c>
<c>4</c><c>DoH</c><c>RFC 8618</c>
<c>5-15</c><c>Unassigned</c><c></c>
</texttable>
<t>Expert reviewers should take the following point into consideration:
Is the requested DNS transport described by a Standards Track RFC?</t>
</section>

<section anchor="data-storage-flags" title="Data Storage Flags">
<t>IANA has created a registry &quot;C-DNS Storage Flags&quot; of
C-DNS data storage flags. The primary purpose of this registry is to provide
indicators giving hints on processing of the data stored.
</t>
<t>The following note is included in this registry: &quot;In version 1.0 of
C-DNS [RFC8618], there is a field describing attributes of the data recorded.
The field is a CBOR <xref target="RFC7049"/> unsigned integer holding bit
flags.&quot;
</t>

<t>The initial contents of the registry are as follows. See 
<xref target="storageparameters"/> of this document:
</t>

<!-- Note: Values below are also in the table in 
Section 7.4.1.1 ("Bit 0," "Bit 1," "Bit 2") -->

<?rfc compact="no"?>
<texttable>
<ttcol align="center">Bit</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">Reference</ttcol>
<c>0</c><c>anonymized-data</c><c>The data has been anonymized.</c><c>RFC 8618</c>
<c>1</c><c>sampled-data</c><c>The data is sampled data.</c><c>RFC 8618</c>
<c>2</c><c>normalized-names</c><c>Names in the data have been normalized.</c><c>RFC 8618</c>
<c>3-63</c><c>Unassigned</c><c></c><c></c>
</texttable>
<?rfc compact="yes"?>

<!-- [rfced] Section 13.2 and Appendix A:  Is "anonymised-data"
a string that may be changed?  We would like to change the
spelling to "anonymized-data" if possible; we ask this because we see
"normalized-names."

Original (best viewed with a fixed-point font such as Courier):
 |  0   | anonymised-data  | The data has been           | [[this    |
 |      |                  | anonymised.                 | RFC]]     |
...
 anonymised-data      : 0,

If this change is acceptable, we will ask IANA to update the
following entry in the "C-DNS Storage Flags" registry on
<https://www.iana.org/assignments/c-dns/> accordingly:

OLD:
0    anonymised-data    The data has been anonymised.

NEW:
0    anonymized-data    The data has been anonymized. *

* We see "Names in the data have been normalized" two entries later. 

Side note: The original document used both British and American spelling;
for internal consistency and consistency with RFC-to-be 8610, it has 
been updated to the latter throughout.

Response: Yes, this change can be made, and IANA updated.
-->

</section>

<section anchor="response-processing-flags" title="Response-Processing Flags">
<t>IANA has created a registry &quot;C-DNS Response Flags&quot;
of C-DNS response-processing flags. The primary purpose of this
registry is to provide indicators giving hints on the generation of a
particular Response.
</t>
<t>The following note is included in this registry: &quot;In version 1.0 of
C-DNS [RFC8618], there is a field describing attributes of the Responses
recorded. The field is a CBOR <xref target="RFC7049"/> unsigned integer
holding bit flags.&quot;
</t>

<t>The initial contents of the registry are as follows.  See 
<xref target="responseprocessingdata"/> of this document:
</t>

<!-- Note: Value 0 in the table below is also listed in the
table in Section 7.6.1. -->

<texttable>
<ttcol align="center">Bit</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">Reference</ttcol>

<c>0</c><c>from-cache</c><c>The Response came from cache.</c><c>RFC 8618</c>
<c>1-63</c><c>Unassigned</c><c></c><c></c>
</texttable>
</section>

<section anchor="addressevent-types" title="AddressEvent Types">
<t>IANA has created a registry &quot;C-DNS Address Event Types&quot;
of C-DNS AddressEvent types. The primary purpose of this registry is
to provide unique identifiers of different types of C-DNS address
events and so specify the contents of the optional companion field
&quot;ae-code&quot; for each type.
</t>
<t>The following note is included in this registry: &quot;In version 1.0 of C-DNS
[RFC8618], there is a field identifying types of the events related
to client addresses. This field is a CBOR <xref target="RFC7049"/> unsigned integer.
There is a related optional field &quot;ae-code&quot;, which, if present,
holds an additional CBOR unsigned integer giving additional information
specific to the event type.&quot;
</t>
<t>The initial contents of the registry are as follows. See 
<xref target="addresseventcount"/> of this document:
</t>

<?rfc compact="no"?>
<texttable>
<ttcol align="center">Identifier</ttcol>
<ttcol align="left">Event Type</ttcol>
<ttcol align="left">ae-code Contents</ttcol>
<ttcol align="left">Reference</ttcol>
<c>0</c><c>TCP reset</c><c>None</c><c>RFC 8618</c>
<c>1</c><c>ICMP time exceeded</c><c>ICMP code <xref target="icmpcodes"/></c><c>RFC 8618</c>
<c>2</c><c>ICMP destination unreachable</c><c>ICMP code <xref target="icmpcodes"/></c><c>RFC 8618</c>
<c>3</c><c>ICMPv6 time exceeded</c><c>ICMPv6 code <xref target="icmp6codes"/></c><c>RFC 8618</c>
<c>4</c><c>ICMPv6 destination unreachable</c><c>ICMPv6 code <xref target="icmp6codes"/></c><c>RFC 8618</c>
<c>5</c><c>ICMPv6 packet too big</c><c>ICMPv6 code <xref target="icmp6codes"/></c><c>RFC 8618</c>
<c>6-18446744073709551615</c><c>Unassigned</c><c></c><c></c>
</texttable>
<?rfc compact="yes"?>

<t>Expert reviewers should take the following point into consideration:
&quot;ae-code&quot; contents must be defined for a type or, if not
appropriate, specified as &quot;None&quot;. A specification of
&quot;None&quot; requires less storage and is therefore preferred.</t>
</section>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>Any control interface MUST perform authentication and encryption.
</t>
<t>Any data upload MUST be authenticated and encrypted.
</t>
</section>

<section anchor="privacy-considerations" title="Privacy Considerations">
<t>Storage of DNS traffic by operators in PCAP and other formats is a
long-standing and widespread practice. Section&nbsp;2.5 of
<xref target="DNS-Priv-Cons"/> provides an analysis of the
risks to Internet users regarding the storage of DNS traffic data in servers
(recursive resolvers, authoritative servers, and rogue servers).
</t>
<t>Section 5.2 of <xref target="DNS-Priv-Svc"/> describes
mitigations for those risks for data stored on recursive resolvers (but that
could by extension apply to authoritative servers). These include
data-handling practices and methods for data minimization, IP address
pseudonymization, and anonymization. Appendix&nbsp;C of
<xref target="DNS-Priv-Svc"/> presents an analysis of seven published
anonymization processes. In addition, the ICANN Root Server System Advisory
Committee (RSSAC) have recently published <xref target="RSSAC04"/>
(&quot;Recommendations on Anonymization Processes for Source IP Addresses
Submitted for Future Analysis&quot;).
</t>
<t>The above analyses consider full data capture (e.g., using PCAP) as a
baseline for privacy considerations; therefore, this format specification
introduces no new user privacy issues beyond those of full data capture (which
are quite severe). It does provide mechanisms to selectively record only
certain fields at the time of data capture, to improve user privacy and to
explicitly indicate that data is sampled, anonymized, or both.

<!-- [rfced] Section 15:  We corrected "does provides" and "and or"
in this sentence as follows.  Please let us know if this is incorrect.

Original:
 It does provides
 mechanisms to selectively record only certain fields at the time of
 data capture to improve user privacy and to explicitly indicate that
 data is sampled and or anonymized.

Currently:
 It does provide
 mechanisms to selectively record only certain fields at the time of
 data capture to improve user privacy and to explicitly indicate that
 data is sampled, anonymized, or both. -->

 It also provides
flags to indicate if data normalization has been performed; data normalization
increases user privacy by reducing the potential for fingerprinting
individuals. However, a trade-off is the potential reduction of the capacity to
identify attack traffic via Query name signatures. Operators should carefully
consider their operational requirements and privacy policies and SHOULD
capture at the source the minimum user data required to meet their needs.
</t>
</section>

</middle>

<back>

<references title="Normative References">

<!-- draft-ietf-cbor-cddl (RFC 8610) in AUTH48 -->
<reference anchor="RFC8610" target="https://www.rfc-editor.org/info/rfc8610">
<front>
<title>Concise Data Definition Language (CDDL): A Notational Convention to 
Express Concise Binary Object Representation (CBOR) and JSON Data Structures</title>
<author initials='H' surname='Birkholz' fullname='Henk Birkholz'>
    <organization />
</author>
<author initials='C' surname='Vigano' fullname='Christoph Vigano'>
    <organization />
</author>
<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>
<date month='June' year='2019' />
</front>
<seriesInfo name="RFC" value="8610"/>
<seriesInfo name="DOI" value="10.17487/RFC8610"/>
</reference>

<?rfc include="reference.RFC.0792"?>
<?rfc include="reference.RFC.1035"?>
<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.3986"?>
<?rfc include="reference.RFC.4443"?>
<?rfc include="reference.RFC.6891"?>
<?rfc include="reference.RFC.7049"?>
<?rfc include="reference.RFC.7858"?>
<?rfc include="reference.RFC.8126"?>
<?rfc include="reference.RFC.8174"?>
<?rfc include="reference.RFC.8484"?>

<reference anchor='pcap-filter' target='https://www.tcpdump.org/manpages/pcap-filter.7.html'>
    <front>
        <title>Manpage of PCAP-FILTER</title>
        <author>
            <organization>tcpdump.org</organization>
        </author>
        <date month="November" year='2017'/>
    </front>
</reference>

<reference anchor='pcap-options' target='https://www.tcpdump.org/manpages/pcap.3pcap.html'>
    <front>
        <title>Manpage of PCAP</title>
        <author>
            <organization>tcpdump.org</organization>
        </author>
        <date month="July" year='2018'/>
    </front>
</reference>

<reference anchor='posix-time'>
    <front>
        <title>IEEE Standard for Information Technology--Portable Operating System Interface (POSIX(R)) Base Specifications, Issue 7</title>
        <author>
            <organization>The Open Group</organization>
        </author>
<!--        <date year='2017'/> -->
    <date/>
    </front>
    <seriesInfo name="IEEE Standard" value="1003.1-2017"/>
    <seriesInfo name="Section" value="4.16"/>
    <seriesInfo name="DOI" value="10.1109/IEEESTD.2018.8277153"/>
</reference>
</references>

<references title="Informative References">

<!-- [rfced] Please note that per current style guidelines we
converted "<eref>" items to Informative References.  Please let us
know if you prefer otherwise. 
-->

<!-- [rfced] As a result of the removal of the "Implementation status"
section, the following URIs are no longer mentioned in this
document.  Please let us know if you would like to (a) leave them out,
(b) add citations of them and have corresponding informative references,
or (c) put the URL in the body of the document.

   [1] https://github.com/dns-stats/compactor/wiki
   [2] https://mm.dns-stats.org/mailman/listinfo/dns-stats-users
   [3] https://www.sinodun.com/2017/06/compressing-pcap-files/
   [4] https://www.sinodun.com/2017/06/more-on-debian-jessieubuntu-
       trusty-packet-capture-woes/

If you choose (b), they would appear as follows in the Informative 
References unless you let us know otherwise.

   [Compactor]
              "DNS-STATS Compactor project homepage", commit 10527b9,
              May 2019, <https://github.com/dns-stats/compactor/wiki>.

   [dns-stats-Users]
              "dns-stats-users - dns-stats Users List",
              <https://mm.dns-stats.org/mailman/listinfo/
              dns-stats-users>.

   [Compress-PCAP]
              Hague, J., "Compressing pcap files", June 2017,
              <https://www.sinodun.com/2017/06/compressing-pcap-files/>.

   [Pkt-Cap-Woes]
              Hague, J., "More on Debian Jessie/Ubuntu Trusty packet
              capture woes", June 2017,
              <https://www.sinodun.com/2017/06/
              more-on-debian-jessieubuntu-trusty-packet-capture-woes/>.

Response: We choose (a).
-->

<!-- draft-dickinson-dprive-bcp-op (Replaced by draft-ietf-dprive-bcp-op)
     (I-D Exists) -->
<reference anchor="DNS-Priv-Svc">
<front>
<title>Recommendations for DNS Privacy Service Operators</title>
<author initials='S' surname='Dickinson' fullname='Sara Dickinson'>
    <organization />
</author>
<author initials='B' surname='Overeinder' fullname='Benno Overeinder'>
    <organization />
</author>
<author initials='R' surname='van Rijswijk-Deij' fullname='Roland van Rijswijk-Deij'>
    <organization />
</author>
<author initials='A' surname='Mankin' fullname='Allison Mankin'>
    <organization />
</author>
<date month='March' year='2019' />
</front>
<seriesInfo name='Work in Progress,' value='draft-ietf-dprive-bcp-op-02' />
</reference>

<!-- [rfced] Informative Reference [I-D.dickinson-dprive-bcp-op]
(draft-dickinson-dprive-bcp-op) has been replaced by
draft-ietf-dprive-bcp-op.  We checked the citations in Section 15 and
changed "Appendix B" to "Appendix C" accordingly.  We also updated
this reference to reflect the current work in progress.
Please let us know any objections.

Original:
 [I-D.dickinson-dprive-bcp-op]
            Dickinson, S., Overeinder, B., Rijswijk-Deij, R., and A.
            Mankin, "Recommendations for DNS Privacy Service
            Operators", draft-dickinson-dprive-bcp-op-01 (work in
            progress), July 2018.

Currently:
 [DNS-Priv-Svc]
            Dickinson, S., Overeinder, B., van Rijswijk-Deij, R., and
            A. Mankin, "Recommendations for DNS Privacy Service
            Operators", Work in Progress, draft-ietf-dprive-bcp-op-02,
            March 2019. -->

<!-- draft-bortzmeyer-dprive-rfc7626-bis (I-D Exists) -->
<reference anchor="DNS-Priv-Cons">
<front>
<title>DNS Privacy Considerations</title>
<author initials='S' surname='Bortzmeyer' fullname='Stephane Bortzmeyer'>
    <organization />
</author>
<author initials='S' surname='Dickinson' fullname='Sara Dickinson'>
    <organization />
</author>
<date month='January' year='2019' />
</front>
<seriesInfo name='Work in Progress,' value='draft-bortzmeyer-dprive-rfc7626-bis-02' />
</reference>

<!-- draft-daley-dnsxml (Expired) -->
<reference anchor='dnsxml'>
<front>
<title>dnsxml - A standard XML representation of DNS data</title>
<author initials='J' surname='Daley' fullname='Jay Daley' role="editor">
    <organization />
</author>
<author initials='S' surname='Morris' fullname='Stephen Morris'>
    <organization />
</author>
<author initials='J' surname='Dickinson' fullname='John Dickinson'>
    <organization />
</author>
<date month='July' year='2013' />
</front>
<seriesInfo name='Work in Progress,' value='draft-daley-dnsxml-00' />
</reference>

<reference anchor="Avro" target="https://avro.apache.org/">
    <front>
        <title>Apache Avro(TM)</title>
        <author>
            <organization>The Apache Software Foundation</organization>
        </author>
        <date year="2019"/>
    </front>
</reference>

<!-- This was removed because it is no longer cited.  (It was only cited in
the "Implementation status" section, which was removed.) 

<reference anchor="Compactor" target="https://github.com/dns-stats/compactor/wiki">
    <front>
        <title>DNS-STATS Compactor project homepage</title>
        <author>
            <organization></organization>
        </author>
        <date month="May" year='2019'/>
    </front>
  <seriesInfo name="commit" value="10527b9"/>
</reference>
-->

<!-- This was removed because it is no longer cited.  (It was only cited in
the "Implementation status" section, which was removed.) 

<reference anchor="Compress-PCAP" target="https://www.sinodun.com/2017/06/compressing-pcap-files/">
    <front>
        <title>Compressing pcap files</title>
        <author initials="J." surname="Hague" fullname="Jim Hague">
            <organization>Sinodun Internet Technologies Ltd.</organization>
        </author>
        <date month="June" year="2017"/>
    </front>
</reference>
-->

<!-- This was removed because it is no longer cited.  (It was only cited in
the "Implementation status" section, which was removed.)

<reference anchor="dns-stats-Users" target="https://mm.dns-stats.org/mailman/listinfo/dns-stats-users">
    <front>
        <title>dns-stats-users - dns-stats Users List</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>
-->

<reference anchor="gzip" target="https://www.gzip.org/">
    <front>
        <title>gzip</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>


<reference anchor="Knot" target="https://www.knot-dns.cz/">
    <front>
        <title>Knot DNS</title>
        <author/>
        <date/>
    </front>
</reference>

<reference anchor="lz4" target="https://lz4.github.io/lz4/">
    <front>
        <title>LZ4</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>


<reference anchor="mmark" target="https://github.com/mmarkdown/mmark">
    <front>
        <title>mmark</title>
        <author initials ="M." surname="Gieben" fullname="Miek Gieben">
            <organization></organization>
        </author>
        <date month="May" year="2019"/>
    </front>
  <seriesInfo name="commit" value="de69698"/>
</reference>

<!-- [rfced] The provided URL for mmark includes a note that
says "!THIS REPOSITORY IS DEPRECATED!"  We updated the listing
accordingly.  Please let us know any objections.

Original:
 [6] https://github.com/miekg/mmark

Currently:
 [mmark]    Gieben, M., "mmark", commit de69698, May 2019,
            <https://github.com/mmarkdown/mmark>. -->

<reference anchor="NSD" target="https://www.nlnetlabs.nl/projects/nsd/about/">
    <front>
        <title>NSD</title>
         <author>
            <organization>NLnet Labs</organization>
         </author>
        <date year="2019"/>
    </front>
</reference>


<!-- This was removed because it is no longer cited.  (It was only cited in
the "Implementation status" section, which was removed.)

<reference anchor="Pkt-Cap-Woes" target="https://www.sinodun.com/2017/06/more-on-debian-jessieubuntu-trusty-packet-capture-woes/">
    <front>
        <title>More on Debian Jessie/Ubuntu Trusty packet capture woes</title>
        <author initials="J." surname="Hague" fullname="Jim Hague">
            <organization>Sinodun Internet Technologies Ltd.</organization>
        </author>
        <date month="June" year="2017"/>
    </front>
</reference>
-->

<reference anchor="Protocol-Buffers" target="https://developers.google.com/protocol-buffers/">
    <front>
        <title>Protocol Buffers</title>
        <author>
            <organization>Google LLC</organization>
        </author>
     <date/>
    </front>
</reference>

<reference anchor="RSSAC04" target="https://www.icann.org/en/system/files/files/rssac-040-07aug18-en.pdf">
    <front>
        <title>Recommendations on Anonymization Processes for Source IP Addresses Submitted for Future Analysis</title>
        <author>
            <organization>ICANN</organization>
        </author>
        <date month="August" year="2018"/>
    </front>
</reference>

<reference anchor="snappy" target="https://google.github.io/snappy/">
    <front>
        <title>snappy</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>

<reference anchor="snzip" target="https://github.com/kubo/snzip">
    <front>
        <title>Snzip, a compression/decompression tool based on snappy</title>
        <author>
            <organization></organization>
        </author>
        <date month="October" year="2018"/>
    </front>
  <seriesInfo name="commit" value="809c6f2"/>
</reference>

<reference anchor="xz" target="https://tukaani.org/xz/">
    <front>
        <title>XZ Utils</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>

<reference anchor="zstd" target="https://facebook.github.io/zstd/">
    <front>
        <title>Zstandard - Real-time data compression algorithm</title>
        <author>
            <organization></organization>
        </author>
        <date/>
    </front>
</reference>

<reference anchor='IEEE802.1Q'>
    <front>
        <title>IEEE Standard for Local and Metropolitan Area Networks--Bridges
	and Bridged Networks</title>
        <author>
            <organization>IEEE</organization>
        </author>
<!--        <date year='2018'/> -->
      <date/>
    </front>
<!--    <seriesInfo name="DOI" value="10.1109/IEEESTD.2018.8403927"/> -->
    <seriesInfo name="IEEE Standard" value="802.1Q"/>
</reference>

<?rfc include="reference.RFC.8259"?>
<?rfc include="reference.RFC.8427"?>

<reference anchor='ditl' target="https://www.dns-oarc.net/oarc/data/ditl">
    <front>
        <title>DITL</title>
        <author>
            <organization>DNS-OARC</organization>
        </author>
        <date year='2018'/>
    </front>
</reference>

<reference anchor='dnscap' target="https://www.dns-oarc.net/tools/dnscap">
    <front>
        <title>DNSCAP</title>
        <author>
            <organization>DNS-OARC</organization>
        </author>
        <date year='2018'/>
    </front>
</reference>

<reference anchor='dnstap' target='https://dnstap.info/'>
    <front>
        <title>dnstap</title>
        <author>
            <organization></organization>
        </author>
        <date year='2016'/>
    </front>
</reference>
<reference anchor='dsc' target='https://www.dns-oarc.net/tools/dsc'>
    <front>
        <title>DSC</title>
        <author initials='D.' surname='Wessels' fullname='Duane Wessels'>
            <organization>Verisign</organization>
        </author>
        <author initials='J.' surname='Lundstrom' fullname='Jerry Lundstrom'>
            <organization>DNS-OARC</organization>
        </author>
        <date year='2016'/>
    </front>
</reference>

<reference anchor='icmp6codes' target='https://www.iana.org/assignments/icmpv6-parameters/'>
    <front>
        <title>ICMPv6 "Code" Fields</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>

<reference anchor='icmpcodes' target='https://www.iana.org/assignments/icmp-parameters/'>
    <front>
        <title>Code Fields</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>
<reference anchor='opcodes' target='https://www.iana.org/assignments/dns-parameters/'>
    <front>
        <title>DNS OpCodes</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>

<reference anchor='packetq' target="https://github.com/DNS-OARC/PacketQ">
    <front>
        <title>PacketQ</title>
        <author>
            <organization>.SE - The Internet Infrastructure Foundation</organization>
        </author>
        <date month="February" year='2019'/>
    </front>
  <seriesInfo name="commit" value="c9b2e89"/>
</reference>

<reference anchor='pcap' target='https://www.tcpdump.org/'>
    <front>
        <title>PCAP</title>
        <author>
            <organization></organization>
        </author>
        <date year='2019'/>
    </front>
</reference>

<reference anchor='pcapng' target='https://github.com/pcapng/pcapng'>
    <front>
        <title>pcapng: PCAP next generation file format specification</title>
        <author>
            <organization></organization>
        </author>
        <date month="March" year='2019'/>
    </front>
  <seriesInfo name="commit" value="3c35b6a"/>
</reference>

<reference anchor='rcodes' target='https://www.iana.org/assignments/dns-parameters/'>
    <front>
        <title>DNS RCODEs</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>

<reference anchor='rrclasses' target='https://www.iana.org/assignments/dns-parameters/'>
    <front>
        <title>DNS CLASSes</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>

<reference anchor='rrtypes' target='https://www.iana.org/assignments/dns-parameters/'>
    <front>
        <title>Resource Record (RR) TYPEs</title>
        <author>
            <organization>IANA</organization>
        </author>
<!--        <date year='2018'/> -->
        <date/>
    </front>
</reference>
</references>

<section anchor="cddl" title="CDDL">
<t>This appendix gives a CDDL <xref target="RFC8610"/> specification for C-DNS.
</t>
<t>CDDL does not permit a range of allowed values to be specified for a bitfield. Where
necessary, those values are given as a CDDL group, but the group definition is
commented out to prevent CDDL tooling from warning that the group is unused.
</t>
<t>
<figure align="center"><artwork align="center">
; CDDL specification of the file format for C-DNS,
; which describes a collection of DNS messages and
; traffic metadata.

;
; The overall structure of a file.
;
File = [
    file-type-id  : "C-DNS",
    file-preamble : FilePreamble,
    file-blocks   : [* Block],
]

;
; The File Preamble.
;
FilePreamble = {
    major-format-version =&gt; 1,
    minor-format-version =&gt; 0,
    ? private-version    =&gt; uint,
    block-parameters     =&gt; [+ BlockParameters],
}
major-format-version = 0
minor-format-version = 1
private-version      = 2
block-parameters     = 3

BlockParameters = {
    storage-parameters      =&gt; StorageParameters,
    ? collection-parameters =&gt; CollectionParameters,
}
storage-parameters    = 0
collection-parameters = 1

  IPv6PrefixLength = 1..128
  IPv4PrefixLength = 1..32
  OpcodeRange = 0..15
  RRTypeRange = 0..65535

  StorageParameters = {
      ticks-per-second             =&gt; uint,
      max-block-items              =&gt; uint,
      storage-hints                =&gt; StorageHints,
      opcodes                      =&gt; [+ OpcodeRange],
      rr-types                     =&gt; [+ RRTypeRange],
      ? storage-flags              =&gt; StorageFlags,
      ? client-address-prefix-ipv4 =&gt; IPv4PrefixLength,
      ? client-address-prefix-ipv6 =&gt; IPv6PrefixLength,
      ? server-address-prefix-ipv4 =&gt; IPv4PrefixLength,
      ? server-address-prefix-ipv6 =&gt; IPv6PrefixLength,
      ? sampling-method            =&gt; tstr,
      ? anonymization-method       =&gt; tstr,
  }
  ticks-per-second           = 0
  max-block-items            = 1
  storage-hints              = 2
  opcodes                    = 3
  rr-types                   = 4
  storage-flags              = 5
  client-address-prefix-ipv4 = 6
  client-address-prefix-ipv6 = 7
  server-address-prefix-ipv4 = 8
  server-address-prefix-ipv6 = 9
  sampling-method            = 10
  anonymization-method       = 11

    ; A hint indicates whether the collection method will output
    ; the item or will ignore the item if present.
    StorageHints = {
        query-response-hints           =&gt; QueryResponseHints,
        query-response-signature-hints =&gt;
            QueryResponseSignatureHints,
        rr-hints                       =&gt; RRHints,
        other-data-hints               =&gt; OtherDataHints,
    }
    query-response-hints           = 0
    query-response-signature-hints = 1
    rr-hints                       = 2
    other-data-hints               = 3

      QueryResponseHintValues = &amp;(
          time-offset                  : 0,
          client-address-index         : 1,
          client-port                  : 2,
          transaction-id               : 3,
          qr-signature-index           : 4,
          client-hoplimit              : 5,
          response-delay               : 6,
          query-name-index             : 7,
          query-size                   : 8,
          response-size                : 9,
          response-processing-data     : 10,
          query-question-sections      : 11,    ; Second &amp; subsequent
                                                ; Questions
          query-answer-sections        : 12,
          query-authority-sections     : 13,
          query-additional-sections    : 14,
          response-answer-sections     : 15,
          response-authority-sections  : 16,
          response-additional-sections : 17,
      )
      QueryResponseHints = uint .bits QueryResponseHintValues

      QueryResponseSignatureHintValues = &amp;(
          server-address     : 0,
          server-port        : 1,
          qr-transport-flags : 2,
          qr-type            : 3,
          qr-sig-flags       : 4,
          query-opcode       : 5,
          dns-flags          : 6,
          query-rcode        : 7,
          query-class-type   : 8,
          query-qdcount      : 9,
          query-ancount      : 10,
          query-arcount      : 11,
          query-nscount      : 12,
          query-edns-version : 13,
          query-udp-size     : 14,
          query-opt-rdata    : 15,
          response-rcode     : 16,
      )
      QueryResponseSignatureHints =
          uint .bits QueryResponseSignatureHintValues

      RRHintValues = &amp;(
          ttl         : 0,
          rdata-index : 1,
      )
      RRHints = uint .bits RRHintValues

      OtherDataHintValues = &amp;(
          malformed-messages   : 0,
          address-event-counts : 1,
      )
      OtherDataHints = uint .bits OtherDataHintValues

    StorageFlagValues = &amp;(
        anonymized-data      : 0,
        sampled-data         : 1,
        normalized-names     : 2,
    )
    StorageFlags = uint .bits StorageFlagValues

 ; Hints for later analysis.
 VLANIdRange = 1..4094

 CollectionParameters = {
      ? query-timeout      =&gt; uint,
      ? skew-timeout       =&gt; uint,
      ? snaplen            =&gt; uint,
      ? promisc            =&gt; bool,
      ? interfaces         =&gt; [+ tstr],
      ? server-addresses   =&gt; [+ IPAddress],
      ? vlan-ids           =&gt; [+ VLANIdRange],
      ? filter             =&gt; tstr,
      ? generator-id       =&gt; tstr,
      ? host-id            =&gt; tstr,
  }
  query-timeout      = 0
  skew-timeout       = 1
  snaplen            = 2
  promisc            = 3
  interfaces         = 4
  server-addresses   = 5
  vlan-ids           = 6
  filter             = 7
  generator-id       = 8
  host-id            = 9

;
; Data in the file is stored in Blocks.
;
Block = {
    block-preamble          =&gt; BlockPreamble,
    ? block-statistics      =&gt; BlockStatistics, ; Much of this
                                                ; could be derived
    ? block-tables          =&gt; BlockTables,
    ? query-responses       =&gt; [+ QueryResponse],
    ? address-event-counts  =&gt; [+ AddressEventCount],
    ? malformed-messages    =&gt; [+ MalformedMessage],
}
block-preamble        = 0
block-statistics      = 1
block-tables          = 2
query-responses       = 3
address-event-counts  = 4
malformed-messages    = 5

;
; The (mandatory) preamble to a block.
;
BlockPreamble = {
    ? earliest-time          =&gt; Timestamp,
    ? block-parameters-index =&gt; uint .default 0,
}
earliest-time          = 0
block-parameters-index = 1

; Ticks are sub-second intervals.  The number of ticks in a second is
; file/block metadata.  Signed and unsigned tick types are defined.
ticks = int
uticks = uint

Timestamp = [
    timestamp-secs   : uint,
    timestamp-uticks : uticks,
]

;
; Statistics about the Block contents.
;
BlockStatistics = {
    ? processed-messages  =&gt; uint,
    ? qr-data-items       =&gt; uint,
    ? unmatched-queries   =&gt; uint,
    ? unmatched-responses =&gt; uint,
    ? discarded-opcode    =&gt; uint,
    ? malformed-items     =&gt; uint,
}
processed-messages  = 0
qr-data-items       = 1
unmatched-queries   = 2
unmatched-responses = 3
discarded-opcode    = 4
malformed-items     = 5

;
; Tables of common data referenced from records in a block.
;
BlockTables = {
    ? ip-address             =&gt; [+ IPAddress],
    ? classtype              =&gt; [+ ClassType],
    ? name-rdata             =&gt; [+ bstr],    ; Holds both names
                                             ; and RDATA
    ? qr-sig                 =&gt; [+ QueryResponseSignature],
    ? QuestionTables,
    ? RRTables,
    ? malformed-message-data =&gt; [+ MalformedMessageData],
}
ip-address             = 0
classtype              = 1
name-rdata             = 2
qr-sig                 = 3
qlist                  = 4
qrr                    = 5
rrlist                 = 6
rr                     = 7
malformed-message-data = 8

IPv4Address = bstr .size 4
IPv6Address = bstr .size 16
IPAddress = IPv4Address / IPv6Address

ClassType = {
    type  =&gt; uint,
    class =&gt; uint,
}
type  = 0
class = 1

QueryResponseSignature = {
    ? server-address-index  =&gt; uint,
    ? server-port           =&gt; uint,
    ? qr-transport-flags    =&gt; QueryResponseTransportFlags,
    ? qr-type               =&gt; QueryResponseType,
    ? qr-sig-flags          =&gt; QueryResponseFlags,
    ? query-opcode          =&gt; uint,
    ? qr-dns-flags          =&gt; DNSFlags,
    ? query-rcode           =&gt; uint,
    ? query-classtype-index =&gt; uint,
    ? query-qd-count        =&gt; uint,
    ? query-an-count        =&gt; uint,
    ? query-ns-count        =&gt; uint,
    ? query-ar-count        =&gt; uint,
    ? edns-version          =&gt; uint,
    ? udp-buf-size          =&gt; uint,
    ? opt-rdata-index       =&gt; uint,
    ? response-rcode        =&gt; uint,
}
server-address-index  = 0
server-port           = 1
qr-transport-flags    = 2
qr-type               = 3
qr-sig-flags          = 4
query-opcode          = 5
qr-dns-flags          = 6
query-rcode           = 7
query-classtype-index = 8
query-qd-count        = 9
query-an-count        = 10
query-ns-count        = 11
query-ar-count        = 12
edns-version          = 13
udp-buf-size          = 14
opt-rdata-index       = 15
response-rcode        = 16

  ; Transport gives the values that may appear in bits 1..4 of
  ; TransportFlags.  There is currently no way to express this in
  ; CDDL, so Transport is unused.  To avoid confusion when used
  ; with CDDL tools, it is commented out.
  ;
  ; Transport = &amp;(
  ;     udp               : 0,
  ;     tcp               : 1,
  ;     tls               : 2,
  ;     dtls              : 3,
  ;     doh               : 4,
  ; )

  TransportFlagValues = &amp;(
      ip-version         : 0,     ; 0=IPv4, 1=IPv6
  ) / (1..4)
  TransportFlags = uint .bits TransportFlagValues

  QueryResponseTransportFlagValues = &amp;(
      query-trailingdata : 5,
  ) / TransportFlagValues
  QueryResponseTransportFlags =
      uint .bits QueryResponseTransportFlagValues

  QueryResponseType = &amp;(
      stub      : 0,
      client    : 1,
      resolver  : 2,
      auth      : 3,
      forwarder : 4,
      tool      : 5,
  )

  QueryResponseFlagValues = &amp;(
      has-query               : 0,
      has-response            : 1,
      query-has-opt           : 2,
      response-has-opt        : 3,
      query-has-no-question   : 4,
      response-has-no-question: 5,
  )
  QueryResponseFlags = uint .bits QueryResponseFlagValues

  DNSFlagValues = &amp;(
      query-cd   : 0,
      query-ad   : 1,
      query-z    : 2,
      query-ra   : 3,
      query-rd   : 4,
      query-tc   : 5,
      query-aa   : 6,
      query-do   : 7,
      response-cd: 8,
      response-ad: 9,
      response-z : 10,
      response-ra: 11,
      response-rd: 12,
      response-tc: 13,
      response-aa: 14,
  )
  DNSFlags = uint .bits DNSFlagValues

QuestionTables = (
    qlist =&gt; [+ QuestionList],
    qrr   =&gt; [+ Question]
)

  QuestionList = [+ uint]           ; Index of Question

  Question = {                      ; Second and subsequent Questions
      name-index      =&gt; uint,      ; Index to a name in the
                                    ; name-rdata table
      classtype-index =&gt; uint,
  }
  name-index      = 0
  classtype-index = 1

RRTables = (
    rrlist =&gt; [+ RRList],
    rr     =&gt; [+ RR]
)

  RRList = [+ uint]                     ; Index of RR

  RR = {
      name-index      =&gt; uint,          ; Index to a name in the
                                        ; name-rdata table
      classtype-index =&gt; uint,
      ? ttl           =&gt; uint,
      ? rdata-index   =&gt; uint,          ; Index to RDATA in the
                                        ; name-rdata table
  }
  ; Other map key values already defined above.
  ttl         = 2
  rdata-index = 3

MalformedMessageData = {
    ? server-address-index   =&gt; uint,
    ? server-port            =&gt; uint,
    ? mm-transport-flags     =&gt; TransportFlags,
    ? mm-payload             =&gt; bstr,
}
; Other map key values already defined above.
mm-transport-flags      = 2
mm-payload              = 3

;
; A single Query/Response data item.
;
QueryResponse = {
    ? time-offset              =&gt; uticks,     ; Time offset from
                                              ; start of block
    ? client-address-index     =&gt; uint,
    ? client-port              =&gt; uint,
    ? transaction-id           =&gt; uint,
    ? qr-signature-index       =&gt; uint,
    ? client-hoplimit          =&gt; uint,
    ? response-delay           =&gt; ticks,
    ? query-name-index         =&gt; uint,
    ? query-size               =&gt; uint,       ; DNS size of Query
    ? response-size            =&gt; uint,       ; DNS size of Response
    ? response-processing-data =&gt; ResponseProcessingData,
    ? query-extended           =&gt; QueryResponseExtended,
    ? response-extended        =&gt; QueryResponseExtended,
}
time-offset              = 0
client-address-index     = 1
client-port              = 2
transaction-id           = 3
qr-signature-index       = 4
client-hoplimit          = 5
response-delay           = 6
query-name-index         = 7
query-size               = 8
response-size            = 9
response-processing-data = 10
query-extended           = 11
response-extended        = 12

ResponseProcessingData = {
    ? bailiwick-index  =&gt; uint,
    ? processing-flags =&gt; ResponseProcessingFlags,
}
bailiwick-index = 0
processing-flags = 1

  ResponseProcessingFlagValues = &amp;(
      from-cache : 0,
  )
  ResponseProcessingFlags = uint .bits ResponseProcessingFlagValues

QueryResponseExtended = {
    ? question-index   =&gt; uint,       ; Index of QuestionList
    ? answer-index     =&gt; uint,       ; Index of RRList
    ? authority-index  =&gt; uint,
    ? additional-index =&gt; uint,
}
question-index   = 0
answer-index     = 1
authority-index  = 2
additional-index = 3

;
; Address event data.
;
AddressEventCount = {
    ae-type          =&gt; &amp;AddressEventType,
    ? ae-code        =&gt; uint,
    ae-address-index =&gt; uint,
    ae-count         =&gt; uint,
}
ae-type          = 0
ae-code          = 1
ae-address-index = 2
ae-count         = 3

AddressEventType = (
    tcp-reset              : 0,
    icmp-time-exceeded     : 1,
    icmp-dest-unreachable  : 2,
    icmpv6-time-exceeded   : 3,
    icmpv6-dest-unreachable: 4,
    icmpv6-packet-too-big  : 5,
)

;
; Malformed messages.
;
MalformedMessage = {
    ? time-offset           =&gt; uticks,   ; Time offset from
                                         ; start of block
    ? client-address-index  =&gt; uint,
    ? client-port           =&gt; uint,
    ? message-data-index    =&gt; uint,
}
; Other map key values already defined above.
message-data-index = 3
</artwork></figure>

<!-- [rfced] Appendix A:  Please advise regarding the following
three items:

A. May we change the two instances of "anonymisation-method" to
"anonymization-method," or is "anonymisation-method" used in code?
(We ask this question because we see "anonymization" in text and
"anonymization-method" at the end of the table in Section 7.4.1.1.)

Original:
 ? anonymisation-method       => tstr,
...
 anonymisation-method       = 11

B. Should the value for query-ns-count be 11, or is it correct for
both query-ns-count and query-ar-count to have a value of 12 (with
nothing in the list having a value of 11)?

Original:
 query-ns-count        = 12
 query-ar-count        = 12

C. May we change "has-reponse" to "has-response," or is
"has-reponse" used in code (i.e., does the misspelled form have to
remain?)?

Original:
 has-reponse             : 1,

Response: Both changes can be made; we have amended the XML.
 -->

</t>
</section>

<section anchor="dns-name-compression-example" title="DNS Name Compression Example">
<t>The basic algorithm, which follows the guidance in <xref target="RFC1035"/>,
is simply to collect each name, and the offset in the packet
at which it starts, during packet construction. As each name is added, it is
offered to each of the collected names in order of collection, starting from
the first name. If (1)&nbsp;labels at the end of the name can be replaced with
a reference back to part (or all) of the earlier name and (2)&nbsp;the
uncompressed part of the name is shorter than any compression already found,
the earlier name is noted as the compression target for the name.
</t>
<t>The following tables illustrate the step by step process of adding
names and performing name compression. In an example packet, the
first name added is foo.example, which cannot be compressed.
</t>

<texttable>
<ttcol align="right">N</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Uncompressed</ttcol>
<ttcol align="left">Compression Target</ttcol>

<c>1</c><c>foo.example</c><c>foo.example</c><c>None</c>
</texttable>

<t>The next name added is bar.example.

<!-- [rfced] Appendix B:  We were confused at first by the empty
cells in the first table.  Is the first table necessary?

Original (best viewed with a fixed-point font such as Courier.
   Dashed lines are broken so XML won't treat them as comments.):

 The following tables illustrate the process.  In an example packet,
 the first name is foo.example.

          +- -+- - - - - - -+- - - - - - - +- - - - - - - - - - +
          | N | Name        | Uncompressed | Compression Target |
          +- -+- - - - - - -+- - - - - - - +- - - - - - - - - - +
          | 1 | foo.example |              |                    |
          +- -+- - - - - - -+- - - - - - - +- - - - - - - - - - +

 The next name added is bar.example. ...

Possibly:
 The following tables illustrate the process.  In an example packet,
 the first name is foo.example.  The next name added is bar.example.
 ... -->

 This is matched against foo.example. The
example part of this can be used as a compression target, with the remaining
uncompressed part of the name being bar.
</t>
<texttable>
<ttcol align="right">N</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Uncompressed</ttcol>
<ttcol align="left">Compression Target</ttcol>

<c>1</c><c>foo.example</c><c>foo.example</c><c>None</c>
<c>2</c><c>bar.example</c><c>bar</c><c>1 + offset to example</c>
</texttable>
<t>The third name added is www.bar.example. This is first matched against
foo.example, and as before this is recorded as a compression target, with the
remaining uncompressed part of the name being www.bar. It is then matched
against the second name, which again can be a compression target. Because the
remaining uncompressed part of the name is www, this is an improved compression,
and so it is adopted.
</t>
<texttable>
<ttcol align="right">N</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Uncompressed</ttcol>
<ttcol align="left">Compression Target</ttcol>

<c>1</c><c>foo.example</c><c>foo.example</c><c>None</c>
<c>2</c><c>bar.example</c><c>bar</c><c>1 + offset to example</c>
<c>3</c><c>www.bar.example</c><c>www</c><c>2</c>
</texttable>
<t>As an optimization, if a name is already perfectly compressed (in other words,
the uncompressed part of the name is empty), then no further names will be considered
for compression.
</t>

<section anchor="nsd-compression-algorithm" title="NSD Compression Algorithm">
<t>Using the above basic algorithm, the packet lengths of Responses generated
by the Name Server Daemon (NSD) <xref target="NSD"/> can be matched
almost exactly. At the time of writing, a tiny number (&lt;.01%) of the
reconstructed packets had incorrect lengths.
</t>
</section>

<section anchor="knot-authoritative-compression-algorithm" title="Knot Authoritative Compression Algorithm">
<t>The Knot Authoritative name server <xref target="Knot"/> uses
different compression behavior, which is the result of internal optimization
designed to balance runtime speed with compression size gains. In
brief, and omitting complications, Knot Authoritative will only consider the
QNAME and names in the immediately preceding RR section in an RRSET as
compression targets.
</t>
<t>A set of smart heuristics as described below can be implemented to mimic
this, and while not perfect, it produces output nearly, but not quite, as good
a match as with NSD. The heuristics are as follows:
</t>
<t>
<list style="numbers">
<t>A match is only perfect if the name is completely compressed AND the TYPE
of the section in which the name occurs matches the TYPE of the name used as
the compression target.</t>
<t>If the name occurs in RDATA:
<list style="symbols">
<t>If the compression target name is in a Query, then only the first RR in an
RRSET can use that name as a compression target.</t>
<t>The compression target name MUST be in RDATA.</t>
<t>The name section TYPE must match the compression target name section
TYPE.</t>
<t>The compression target name MUST be in the immediately preceding RR in the
RRSET.</t>
</list></t>
</list>
</t>
<t>Using this algorithm, less than 0.1% of the reconstructed packets had
incorrect lengths.
</t>
</section>

<section anchor="observed-differences" title="Observed Differences">
<t>In sample traffic collected on a root name server, around 2-4% of Responses
generated by Knot had different packet lengths than those produced by NSD.
</t>
</section>
</section>

<section anchor="comparison-of-binary-formats" title="Comparison of Binary Formats">
<t>Several binary serialization formats were considered. For completeness,
they were also compared to JSON.
</t>
<t>

<list style="symbols">
<t>
Apache Avro <xref target="Avro"/>. Data is stored according to
a predefined schema. The schema itself is always included in the
data file. Data can therefore be stored untagged, for a smaller
serialization size, and be written and read by an Avro library.
<list style="symbols">
<t>At the time of writing, Avro libraries are available for C, C++, C#,
Java, Python, Ruby, and PHP. Optionally, tools are available for C++,
Java, and C# to generate code for encoding and decoding.</t>
</list></t>

<t>Google Protocol Buffers <xref target="Protocol-Buffers"/>. Data is
stored according to a predefined schema. The schema is used by a
generator to generate code for encoding and decoding the data. Data
can therefore be stored untagged, for a smaller serialization size.
The schema is not stored with the data, so unlike Avro, it cannot be
read with a generic library.
<list style="symbols">
<t>Code must be generated for a particular data schema to
read and write data using that schema. At the time of
writing, the Google code generator can currently generate code
for encoding and decoding a schema for C++, Go,
Java, Python, Ruby, C#, Objective-C, JavaScript, and PHP.</t>
</list></t>

<t>CBOR <xref target="RFC7049"/>. This
serialization format is comparable to JSON but with a binary
representation. It does not use a predefined schema, so data is always stored
tagged. However, CBOR data schemas can be described using CDDL
<xref target="RFC8610"/>, and tools exist to verify that data files conform to
the schema.
<list style="symbols">
<t>CBOR is a simple format and is simple to implement. At the time of writing,
the CBOR website lists implementations for 16 languages.</t>
</list></t>
</list>
</t>
<t>Avro and Protocol Buffers both allow storage of untagged data, but
because they rely on the data schema for this, their implementation is
considerably more complex than CBOR. Using Avro or Protocol Buffers in
an unsupported environment would require notably greater development
effort compared to CBOR.
</t>
<t>A test program was written that reads input from a PCAP file
and writes output using one of two basic structures:
either a simple structure, where each Query/Response pair is represented in a
single record entry, or the C-DNS block structure.
</t>
<t>The resulting output files were then compressed using a variety of common
general-purpose lossless compression tools to explore the
compressibility of the formats. The compression tools employed were:
</t>

<t>
<list style="symbols">
<t>snzip <xref target="snzip"/>. A command-line compression tool based on the
Google Snappy library <xref target="snappy"/>.</t>
<t>lz4 <xref target="lz4"/>. The command-line compression tool from the
reference C LZ4 implementation.</t>
<t>gzip <xref target="gzip"/>. The ubiquitous GNU zip tool.</t>
<t>zstd <xref target="zstd"/>. Compression using the Zstandard algorithm.</t>
<t>xz <xref target="xz"/>. A popular compression tool noted for high
compression.</t>
</list>
</t>

<t>In all cases, the compression tools were run using their default settings.
</t>
<t>Note that this document does not mandate the use of compression, nor any
particular compression scheme, but it anticipates that in practice
output data will be subject to general-purpose compression, and so
this should be taken into consideration.
</t>
<t>&quot;test.pcap&quot;, a 662 MB capture of sample data from a root
instance, was used for the comparison. The following table shows the
formatted size and size after compression (abbreviated to Comp. in the
table headers), together with the task Resident Set Size (RSS) and the
user time taken by the compression. File sizes are in MB, RSS is in kB,
and user time is in seconds.
</t>
<texttable>
<ttcol align="left">Format</ttcol>
<ttcol align="right">File Size</ttcol>
<ttcol align="left">Comp.</ttcol>
<ttcol align="right">Comp. Size</ttcol>
<ttcol align="right">RSS</ttcol>
<ttcol align="right">User Time</ttcol>

<c>PCAP</c><c>661.87</c><c>snzip</c><c>212.48</c><c>2696</c><c>1.26</c>
<c></c><c></c><c>lz4</c><c>181.58</c><c>6336</c><c>1.35</c>
<c></c><c></c><c>gzip</c><c>153.46</c><c>1428</c><c>18.20</c>
<c></c><c></c><c>zstd</c><c>87.07</c><c>3544</c><c>4.27</c>
<c></c><c></c><c>xz</c><c>49.09</c><c>97416</c><c>160.79</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>JSON simple</c><c>4113.92</c><c>snzip</c><c>603.78</c><c>2656</c><c>5.72</c>
<c></c><c></c><c>lz4</c><c>386.42</c><c>5636</c><c>5.25</c>
<c></c><c></c><c>gzip</c><c>271.11</c><c>1492</c><c>73.00</c>
<c></c><c></c><c>zstd</c><c>133.43</c><c>3284</c><c>8.68</c>
<c></c><c></c><c>xz</c><c>51.98</c><c>97412</c><c>600.74</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>Avro simple</c><c>640.45</c><c>snzip</c><c>148.98</c><c>2656</c><c>0.90</c>
<c></c><c></c><c>lz4</c><c>111.92</c><c>5828</c><c>0.99</c>
<c></c><c></c><c>gzip</c><c>103.07</c><c>1540</c><c>11.52</c>
<c></c><c></c><c>zstd</c><c>49.08</c><c>3524</c><c>2.50</c>
<c></c><c></c><c>xz</c><c>22.87</c><c>97308</c><c>90.34</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>CBOR simple</c><c>764.82</c><c>snzip</c><c>164.57</c><c>2664</c><c>1.11</c>
<c></c><c></c><c>lz4</c><c>120.98</c><c>5892</c><c>1.13</c>
<c></c><c></c><c>gzip</c><c>110.61</c><c>1428</c><c>12.88</c>
<c></c><c></c><c>zstd</c><c>54.14</c><c>3224</c><c>2.77</c>
<c></c><c></c><c>xz</c><c>23.43</c><c>97276</c><c>111.48</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>PBuf simple</c><c>749.51</c><c>snzip</c><c>167.16</c><c>2660</c><c>1.08</c>
<c></c><c></c><c>lz4</c><c>123.09</c><c>5824</c><c>1.14</c>
<c></c><c></c><c>gzip</c><c>112.05</c><c>1424</c><c>12.75</c>
<c></c><c></c><c>zstd</c><c>53.39</c><c>3388</c><c>2.76</c>
<c></c><c></c><c>xz</c><c>23.99</c><c>97348</c><c>106.47</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>JSON block</c><c>519.77</c><c>snzip</c><c>106.12</c><c>2812</c><c>0.93</c>
<c></c><c></c><c>lz4</c><c>104.34</c><c>6080</c><c>0.97</c>
<c></c><c></c><c>gzip</c><c>57.97</c><c>1604</c><c>12.70</c>
<c></c><c></c><c>zstd</c><c>61.51</c><c>3396</c><c>3.45</c>
<c></c><c></c><c>xz</c><c>27.67</c><c>97524</c><c>169.10</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>Avro block</c><c>60.45</c><c>snzip</c><c>48.38</c><c>2688</c><c>0.20</c>
<c></c><c></c><c>lz4</c><c>48.78</c><c>8540</c><c>0.22</c>
<c></c><c></c><c>gzip</c><c>39.62</c><c>1576</c><c>2.92</c>
<c></c><c></c><c>zstd</c><c>29.63</c><c>3612</c><c>1.25</c>
<c></c><c></c><c>xz</c><c>18.28</c><c>97564</c><c>25.81</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>CBOR block</c><c>75.25</c><c>snzip</c><c>53.27</c><c>2684</c><c>0.24</c>
<c></c><c></c><c>lz4</c><c>51.88</c><c>8008</c><c>0.28</c>
<c></c><c></c><c>gzip</c><c>41.17</c><c>1548</c><c>4.36</c>
<c></c><c></c><c>zstd</c><c>30.61</c><c>3476</c><c>1.48</c>
<c></c><c></c><c>xz</c><c>18.15</c><c>97556</c><c>38.78</c>
<c></c><c></c><c></c><c></c><c></c><c></c>
<c>PBuf block</c><c>67.98</c><c>snzip</c><c>51.10</c><c>2636</c><c>0.24</c>
<c></c><c></c><c>lz4</c><c>52.39</c><c>8304</c><c>0.24</c>
<c></c><c></c><c>gzip</c><c>40.19</c><c>1520</c><c>3.63</c>
<c></c><c></c><c>zstd</c><c>31.61</c><c>3576</c><c>1.40</c>
<c></c><c></c><c>xz</c><c>17.94</c><c>97440</c><c>33.99</c>
</texttable>
<t>The above results are discussed in the following sections.
</t>

<section anchor="comparison-with-full-pcap-files" title="Comparison with Full PCAP Files">
<t>An important first consideration is whether moving away from PCAP
offers significant benefits.
</t>
<t>The simple binary formats are typically larger than PCAP, even though
they omit some information such as Ethernet Media Access Control (MAC)
addresses. But not only do they require less CPU to compress than PCAP, the
resulting compressed files are smaller than compressed PCAP.
</t>
</section>

<section anchor="simple-versus-block-coding" title="Simple versus Block Coding">
<t>The intention of the block coding is to perform data deduplication on
Query/Response records within the block. The simple and block formats
shown above store exactly the same information for each Query&wj;/Response
record. This information is parsed from the DNS traffic in the input
PCAP file, and in all cases each field has an identifier and the field
data is typed.
</t>
<t>The data deduplication on the block formats show an
order-of-magnitude reduction in the size of the format file size against the
simple formats. As would be expected, the compression tools are able
to find and exploit a lot of this duplication, but as the
deduplication process uses knowledge of DNS traffic, it is able to
retain a size advantage. This advantage reduces as stronger
compression is applied, as again would be expected, but even with the
strongest compression applied the block-formatted data remains around
75% of the size of the simple format and its compression requires
roughly a third of the CPU time.
</t>
</section>

<section anchor="binary-versus-text-formats" title="Binary versus Text Formats">
<t>Text data formats offer many advantages over binary formats,
particularly in the areas of ad hoc data inspection and extraction. It
was therefore felt worthwhile to carry out a direct comparison,
implementing JSON versions of the simple and block formats.
</t>
<t>Concentrating on JSON block format, the format files produced are a
significant fraction of an order of magnitude larger than binary
formats. The impact on file size after compression is as might be
expected from that starting point; the stronger compression produces
files that are 150% of the size of similarly compressed binary format
and require over 4x more CPU to compress.
</t>
</section>

<section anchor="performance" title="Performance">
<t>Concentrating again on the block formats, all three produce format
files that are close to an order of magnitude smaller than the
original &quot;test.pcap&quot; file.  CBOR produces the largest files and Avro
the smallest, 20% smaller than CBOR.
</t>
<t>However, once compression is taken into account, the size difference
narrows. At medium compression (with gzip), the size difference is 4%.
Using strong compression (with xz), the difference reduces to 2%, with Avro
the largest and Protocol Buffers the smallest, although CBOR and Protocol
Buffers require slightly more compression CPU.
</t>
<t>The measurements presented above do not include data on the CPU
required to generate the format files. Measurements indicate
that writing Avro requires 10% more CPU than CBOR or Protocol Buffers.
It appears, therefore, that Avro's advantage in compression CPU usage
is probably offset by a larger CPU requirement in writing Avro.
</t>
</section>

<section anchor="conclusions" title="Conclusions">
<t>The above assessments lead us to the choice of a binary format file
using blocking.
</t>
<t>As noted previously, this document anticipates that output data will be
subject to compression. There is no compelling case for one particular
binary serialization format in terms of either final file size or
machine resources consumed, so the choice must be largely based on
other factors. CBOR was therefore chosen as the binary serialization format for
the reasons listed in <xref target="choice-of-cbor"/>.
</t>
</section>

<section anchor="block-size-choice" title="Block Size Choice">
<t>Given the choice of a CBOR format using blocking, the question arises
of what an appropriate default value for the maximum number of
Query&wj;/Response pairs in a block should be. This has two components:</t>
<t><list style="numbers">
<t>What is the impact on performance of using different block sizes in
the format file?</t>
<t>What is the impact on the size of the format file before and after
compression?</t>
</list></t>

<t>The following table addresses the performance question, showing the
impact on the performance of a C++ program converting &quot;test.pcap&quot;
to C-DNS. File sizes are in MB, and RSS is in kB.
</t>

<!-- [rfced] Appendix C.6:  Is the user time shown in the first
table in this subsection expressed in seconds?  If yes, would it
be appropriate to update the sentence preceding the table, per text
in Appendix C?

Original:
 File size is in Mb, resident set size (RSS) in kb.

Possibly:
 File sizes are in MB, RSS is in kB, and user time is in seconds. -->

<texttable>
<ttcol align="right">Block Size</ttcol>
<ttcol align="right">File Size</ttcol>
<ttcol align="right">RSS</ttcol>
<ttcol align="right">User Time</ttcol>

<c>1,000</c><c>133.46</c><c>612.27</c><c>15.25</c>
<c>5,000</c><c>89.85</c><c>676.82</c><c>14.99</c>
<c>10,000</c><c>76.87</c><c>752.40</c><c>14.53</c>
<c>20,000</c><c>67.86</c><c>750.75</c><c>14.49</c>
<c>40,000</c><c>61.88</c><c>736.30</c><c>14.29</c>
<c>80,000</c><c>58.08</c><c>694.16</c><c>14.28</c>
<c>160,000</c><c>55.94</c><c>733.84</c><c>14.44</c>
<c>320,000</c><c>54.41</c><c>799.20</c><c>13.97</c>
</texttable>
<t>Therefore, increasing block size tends to increase maximum RSS a
little, with no significant effect (if anything, a small reduction) on
CPU consumption.
</t>
<t>The following table demonstrates the effect of increasing block size
on output file size for different compressions.
</t>
<texttable>
<ttcol align="right">Block Size</ttcol>
<ttcol align="right">None</ttcol>
<ttcol align="right">snzip</ttcol>
<ttcol align="right">lz4</ttcol>
<ttcol align="right">gzip</ttcol>
<ttcol align="right">zstd</ttcol>
<ttcol align="right">xz</ttcol>

<c>1,000</c><c>133.46</c><c>90.52</c><c>90.03</c><c>74.65</c><c>44.78</c><c>25.63</c>
<c>5,000</c><c>89.85</c><c>59.69</c><c>59.43</c><c>46.99</c><c>37.33</c><c>22.34</c>
<c>10,000</c><c>76.87</c><c>50.39</c><c>50.28</c><c>38.94</c><c>33.62</c><c>21.09</c>
<c>20,000</c><c>67.86</c><c>43.91</c><c>43.90</c><c>33.24</c><c>32.62</c><c>20.16</c>
<c>40,000</c><c>61.88</c><c>39.63</c><c>39.69</c><c>29.44</c><c>28.72</c><c>19.52</c>
<c>80,000</c><c>58.08</c><c>36.93</c><c>37.01</c><c>27.05</c><c>26.25</c><c>19.00</c>
<c>160,000</c><c>55.94</c><c>35.10</c><c>35.06</c><c>25.44</c><c>24.56</c><c>19.63</c>
<c>320,000</c><c>54.41</c><c>33.87</c><c>33.74</c><c>24.36</c><c>23.44</c><c>18.66</c>
</texttable>
<t>There is obviously scope for tuning the default block
size to the compression being employed, traffic characteristics, frequency of
output file rollover, etc. Using a strong compression scheme, block sizes over
10,000 Query/Response pairs would seem to offer limited improvements.
</t>
</section>
</section>

<section anchor="acknowledgements" title="Acknowledgements" numbered="no">
<t>The authors wish to thank CZ.NIC -- in particular, Tomas Gavenciak --
for many useful discussions on binary formats, compression, and packet
matching. Thanks also to Jan Vcelak and Wouter Wijngaards for discussions on
name compression, and Paul Hoffman for a detailed review of this document and
the C-DNS CDDL.
</t>

<t>Thanks also to Robert Edmonds, Jerry Lundstrom, Richard Gibson, Stephane
Bortzmeyer, and many other members of DNSOP for review.</t>

<t>Also, thanks to Miek Gieben for <xref target="mmark"/>.

</t>
</section>

</back>

<!-- [rfced] FYI, the following term (which appears 3 times) has been 
updated to the latter form in order to match how it appears in
the normative reference draft-ietf-cbor-cddl-08 (RFC-to-be 8610).
Please let us know if you prefer otherwise.

  data type vs. datatype
-->

<!-- [rfced] Please let us know if any changes are needed for the
following:

a) The following terms were used inconsistently in this document.
We chose to use the latter forms.  Please let us know any objections.

 nameserver (1 instance) / name server (16 instances)
 Opt RDATA / OPT RDATA (per RFC 6891)

b) The following terms appear to be used inconsistently in this
document.  Please let us know which form is preferred.

 Block table(s) / Block Table(s) / block table(s) (in text)
 BlockTable / BlockTables
 subsequent question / subsequent Question
 query / Query (including general usage in running text)*
   (e.g., "DNS query" vs. "DNS Query"; note that we see "DNS response"
    in text but not "DNS Response"; "a Query and a Response" vs.
    "a query and a response," "query or response" vs. "Query or
    Response")

 queries / Queries (including general usage in running text)*
 response(s) / Response(s) (including general usage in running text)
   (e.g., "a response" vs. "a Response")*
 query/response / Query/Response (in running text)*

 * Do "Q/R," "QR," and "query/response" (or "Query/Response") mean
   the same thing?  We see that "Q/R" is consistently capitalized.
   If yes, perhaps we could change "(a "Q/R data item")" in Section 4
   to "(a "Query/Response (Q/R) data item")" and use "Q/R" after that.

 response data / Response data (We see "Query data" used in this
   document.)

 DNS Header / DNS header (1 instance each, in text)

 file preamble (text) / File preamble (Figure 1) / File Preamble (text)
 Block preamble (Figure 1) / Block Preamble (text)
 Block parameters (Figure 1) / Block Parameters (text)
 file Format Version (text) / file format version (text)
   (We see "Format version" in Figure 1.)
 File type identifier (Figure 1)/ File Type Identifier (text)
 Client hoplimit (Figure 2) / Client Hoplimit
   (We see "IPv6 Hoplimit" in the table in Section 7.6.)
 query signature (text) / Query signature (Figure 2) /
   Query Signature (Figure 2 and also in text)
 Class/type (Figure 2) / Class/Type (Figure 2)
 QD count (Figure 2) / QDCOUNT (table in Section 7.5.3.2, text)
 AN count (Figure 2) / ANCOUNT ((table in Section 7.5.3.2)
 NS count (Figure 2) / NSCOUNT (table in Section 7.5.3.2)

 Please confirm that the following are distinct items (perhaps the
   latter forms are the "-hints" variation?):
   query-qd-count vs. query-qdcount
   query-an-count vs. query-ancount
   query-ns-count vs. query-nscount
   query-ar-count vs. query-arcount

 ARCount / ARCOUNT
 data blocks / data Blocks
 the block / the Block (used generally in text)
 block statistics (text) / Block statistics (Figure 1)
   / Block Statistics (text)
 collection and storage parameters / Collection and Storage Parameters

 Address/Event Count data items / Address/Event Counts data item
   (We ask because we see "AddressEventCount" and
    "address-event-counts.")

 and subsequent questions / and subsequent Questions

 secondary ID / Secondary ID
   (e.g., "the secondary ID" vs. "the Secondary ID"; we see
    "Primary ID" in this document but not "primary ID") -->

</rfc>
